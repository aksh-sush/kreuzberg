{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Kreuzberg","text":"<p>Kreuzberg is a Python library for text extraction from documents. It provides a unified async interface for extracting text from PDFs, images, office documents, and more.</p>"},{"location":"#why-kreuzberg","title":"Why Kreuzberg?","text":"<ul> <li>Simple and Hassle-Free: Clean API that just works, without complex configuration</li> <li>Local Processing: No external API calls or cloud dependencies required</li> <li>Resource Efficient: Lightweight processing without GPU requirements</li> <li>Small Package Size: Has few curated dependencies and a minimal footprint</li> <li>Format Support: Comprehensive support for documents, images, and text formats</li> <li>Modern Python: Built with async/await, type hints, and functional first approach</li> <li>Permissive OSS: Kreuzberg and its dependencies have a permissive OSS license</li> </ul> <p>Kreuzberg was built for RAG (Retrieval Augmented Generation) applications, focusing on local processing with minimal dependencies. Its designed for modern async applications, serverless functions, and dockerized applications.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to Kreuzberg will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Documentation site with comprehensive examples and API reference</li> <li>Improved configuration for all OCR backends</li> <li>Added hooks system for validation and post-processing</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Refactored internal structure for better maintainability</li> <li>Updated extraction functions to use config object instead of kwargs</li> <li>Improved error messages and reporting</li> </ul>"},{"location":"changelog/#010-2023-11-15","title":"[0.1.0] - 2023-11-15","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Initial release</li> <li>Support for PDF, image, and Office document extraction</li> <li>OCR capabilities with Tesseract</li> <li>Basic error handling and reporting</li> <li>Async and sync APIs</li> </ul>"},{"location":"contributing/","title":"Contributing to Kreuzberg","text":"<p>Thank you for considering contributing to Kreuzberg! This document provides guidelines and instructions for contributing to the project.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<ol> <li> <p>Clone the repository:</p> <pre><code>git clone https://github.com/Goldziher/kreuzberg.git\ncd kreuzberg\n</code></pre> </li> <li> <p>Create and activate a virtual environment:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n</code></pre> </li> <li> <p>Install development dependencies:</p> <pre><code>pip install -e \".[dev,docs]\"\n</code></pre> </li> </ol>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code>pytest\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":"<p>This project uses:</p> <ul> <li>Black for code formatting</li> <li>isort for import sorting</li> <li>mypy for static type checking</li> <li>ruff for linting</li> </ul> <p>You can run all style checks with:</p> <pre><code>black .\nisort .\nmypy .\nruff check .\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Documentation is built with MkDocs using the Material for MkDocs theme.</p> <p>To build and serve the documentation locally:</p> <pre><code>mkdocs serve\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch (<code>git checkout -b feature/amazing-feature</code>)</li> <li>Commit your changes (<code>git commit -m 'Add some amazing feature'</code>)</li> <li>Push to the branch (<code>git push origin feature/amazing-feature</code>)</li> <li>Open a Pull Request</li> </ol>"},{"location":"contributing/#license","title":"License","text":"<p>By contributing to Kreuzberg, you agree that your contributions will be licensed under the project's MIT License.</p>"},{"location":"advanced/","title":"Advanced Topics","text":"<p>This section covers advanced features and usage patterns for Kreuzberg.</p>"},{"location":"advanced/#topics","title":"Topics","text":"<ul> <li>Error Handling - Detailed strategies for handling extraction errors</li> <li>Custom Hooks - Creating custom validation and post-processing hooks</li> <li>Custom Extractors - Adding and removing custom extractors</li> </ul>"},{"location":"advanced/#advanced-configuration","title":"Advanced Configuration","text":"<p>Kreuzberg allows you to deeply customize the extraction process through:</p> <ol> <li>Validation Hooks: Apply custom validation rules to extraction results</li> <li>Post-Processing Hooks: Transform extraction results before they're returned</li> <li>Custom OCR Settings: Fine-tune OCR behavior for specific document types</li> </ol>"},{"location":"advanced/#custom-validation-example","title":"Custom Validation Example","text":"<pre><code>from kreuzberg import extract_file, ExtractionConfig, ExtractionResult\nfrom kreuzberg import ValidationError\n\n# Define a custom validator that requires a minimum text length\ndef validate_text_length(result: ExtractionResult) -&gt; None:\n    if len(result.content) &lt; 100:\n        raise ValidationError(\"Extracted text is too short\", context={\"content_length\": len(result.content)})\n\n# Use the validator in extraction\nasync def extract_with_validation(file_path):\n    config = ExtractionConfig(validators=[validate_text_length])\n\n    try:\n        result = await extract_file(file_path, config=config)\n        return result.content\n    except ValidationError as e:\n        print(f\"Validation failed: {e}\")\n        return None\n</code></pre>"},{"location":"advanced/custom-extractors/","title":"Custom Extractors","text":"<p>Kreuzberg provides a flexible system for adding and removing custom extractors through the <code>ExtractorRegistry</code>. This allows you to extend Kreuzberg's capabilities to handle additional file formats or customize how existing formats are processed.</p>"},{"location":"advanced/custom-extractors/#creating-a-custom-extractor","title":"Creating a Custom Extractor","text":"<p>To create a custom extractor, you need to subclass the <code>Extractor</code> abstract base class and implement its required methods:</p> <pre><code>from kreuzberg import ExtractorRegistry, ExtractionResult, ExtractionConfig\nfrom kreuzberg._extractors._base import Extractor\nfrom pathlib import Path\n\nclass CustomExtractor(Extractor):\n    \"\"\"Custom extractor for handling a specific file format.\"\"\"\n\n    # Define the MIME types this extractor supports\n    SUPPORTED_MIME_TYPES = {\"application/x-custom\", \"application/x-custom-format\"}\n\n    async def extract_bytes_async(self, content: bytes) -&gt; ExtractionResult:\n        \"\"\"Asynchronously extract content from bytes.\"\"\"\n        # Implement your extraction logic here\n        extracted_text = self._process_content(content)\n\n        return ExtractionResult(content=extracted_text, mime_type=self.mime_type, metadata={\"extractor\": \"CustomExtractor\"})\n\n    async def extract_path_async(self, path: Path) -&gt; ExtractionResult:\n        \"\"\"Asynchronously extract content from a file path.\"\"\"\n        # Read the file and process it\n        content = await self._read_file_async(path)\n        return await self.extract_bytes_async(content)\n\n    def extract_bytes_sync(self, content: bytes) -&gt; ExtractionResult:\n        \"\"\"Synchronously extract content from bytes.\"\"\"\n        # Implement your extraction logic here\n        extracted_text = self._process_content(content)\n\n        return ExtractionResult(content=extracted_text, mime_type=self.mime_type, metadata={\"extractor\": \"CustomExtractor\"})\n\n    def extract_path_sync(self, path: Path) -&gt; ExtractionResult:\n        \"\"\"Synchronously extract content from a file path.\"\"\"\n        # Read the file and process it\n        with open(path, \"rb\") as f:\n            content = f.read()\n        return self.extract_bytes_sync(content)\n\n    def _process_content(self, content: bytes) -&gt; str:\n        \"\"\"Process the content and extract text.\"\"\"\n        # Implement your content processing logic here\n        # This is just an example\n        return content.decode(\"utf-8\", errors=\"ignore\")\n\n    async def _read_file_async(self, path: Path) -&gt; bytes:\n        \"\"\"Read a file asynchronously.\"\"\"\n        # This is a simple implementation; you might want to use aiofiles in practice\n        with open(path, \"rb\") as f:\n            return f.read()\n</code></pre>"},{"location":"advanced/custom-extractors/#registering-a-custom-extractor","title":"Registering a Custom Extractor","text":"<p>Once you've created your custom extractor, you can register it with Kreuzberg using the <code>ExtractorRegistry</code>:</p> <pre><code>from kreuzberg import ExtractorRegistry\nfrom my_module import CustomExtractor\n\n# Register the custom extractor\nExtractorRegistry.add_extractor(CustomExtractor)\n\n# Now you can use it with standard extraction functions\nfrom kreuzberg import extract_file\n\nresult = await extract_file(\"custom_document.xyz\")\n</code></pre>"},{"location":"advanced/custom-extractors/#extractor-priority","title":"Extractor Priority","text":"<p>Extractors are tried in the order they are registered. When extracting content, Kreuzberg will:</p> <ol> <li>Try all user-registered extractors first (in the order they were added)</li> <li>Then try all default extractors</li> </ol> <p>This means your custom extractors take precedence over the built-in ones. If you want to override how a specific MIME type is handled, you can register a custom extractor that supports that MIME type.</p>"},{"location":"advanced/custom-extractors/#removing-an-extractor","title":"Removing an Extractor","text":"<p>You can remove a previously registered extractor:</p> <pre><code>from kreuzberg import ExtractorRegistry\nfrom my_module import CustomExtractor\n\n# First register it\nExtractorRegistry.add_extractor(CustomExtractor)\n\n# Later, remove it when no longer needed\nExtractorRegistry.remove_extractor(CustomExtractor)\n</code></pre>"},{"location":"advanced/custom-extractors/#ocr-configuration-in-custom-extractors","title":"OCR Configuration in Custom Extractors","text":"<p>When creating custom extractors that need OCR capabilities, you can leverage Kreuzberg's OCR configuration options:</p> <pre><code>from kreuzberg import ExtractorRegistry, ExtractionResult, ExtractionConfig, TesseractConfig, PSMMode\nfrom kreuzberg._extractors._base import Extractor\n\nclass CustomImageExtractor(Extractor):\n    \"\"\"Custom extractor for image files with OCR capabilities.\"\"\"\n\n    SUPPORTED_MIME_TYPES = {\"image/custom\"}\n\n    def extract_bytes_sync(self, content: bytes) -&gt; ExtractionResult:\n        # Get OCR configuration from the extraction config\n        ocr_config = self.config.ocr_config\n\n        if isinstance(ocr_config, TesseractConfig):\n            # Access Tesseract-specific settings\n            language = ocr_config.language  # Language model to use (e.g., \"eng\", \"deu\")\n            psm = ocr_config.psm  # Page segmentation mode\n\n            # Use these settings in your OCR processing\n            # ...\n\n        # Implement the rest of your extraction logic\n        # ...\n\n        return ExtractionResult(content=\"Extracted text\", mime_type=self.mime_type, metadata={\"ocr_engine\": \"tesseract\"})\n    # Implement other required methods...\n</code></pre>"},{"location":"advanced/custom-extractors/#example-custom-csv-extractor","title":"Example: Custom CSV Extractor","text":"<p>Here's a complete example of a custom CSV extractor that extracts text from CSV files:</p> <pre><code>from kreuzberg import ExtractorRegistry, ExtractionResult, ExtractionConfig\nfrom kreuzberg._extractors._base import Extractor\nfrom pathlib import Path\nimport csv\nimport io\n\nclass CSVExtractor(Extractor):\n    \"\"\"Custom extractor for CSV files.\"\"\"\n\n    SUPPORTED_MIME_TYPES = {\"text/csv\", \"application/csv\"}\n\n    async def extract_bytes_async(self, content: bytes) -&gt; ExtractionResult:\n        return self.extract_bytes_sync(content)\n\n    async def extract_path_async(self, path: Path) -&gt; ExtractionResult:\n        with open(path, \"rb\") as f:\n            content = f.read()\n        return await self.extract_bytes_async(content)\n\n    def extract_bytes_sync(self, content: bytes) -&gt; ExtractionResult:\n        text_content = content.decode(\"utf-8\", errors=\"ignore\")\n        extracted_text = self._process_csv(text_content)\n\n        return ExtractionResult(\n            content=extracted_text, mime_type=self.mime_type, metadata={\"extractor\": \"CSVExtractor\", \"format\": \"csv\"}\n        )\n\n    def extract_path_sync(self, path: Path) -&gt; ExtractionResult:\n        with open(path, \"rb\") as f:\n            content = f.read()\n        return self.extract_bytes_sync(content)\n\n    def _process_csv(self, csv_content: str) -&gt; str:\n        \"\"\"Process CSV content and convert to plain text.\"\"\"\n        output = []\n        csv_file = io.StringIO(csv_content)\n\n        try:\n            reader = csv.reader(csv_file)\n            headers = next(reader, None)\n\n            if headers:\n                output.append(\" | \".join(headers))\n                output.append(\"-\" * 40)\n\n            for row in reader:\n                output.append(\" | \".join(row))\n\n        except Exception as e:\n            output.append(f\"Error processing CSV: {str(e)}\")\n\n        return \"\\n\".join(output)\n\n# Register the custom extractor\nExtractorRegistry.add_extractor(CSVExtractor)\n</code></pre>"},{"location":"advanced/custom-extractors/#best-practices","title":"Best Practices","text":"<ol> <li>Define clear MIME type support: Be specific about which MIME types your extractor supports</li> <li>Implement both sync and async methods: Ensure your extractor works in both synchronous and asynchronous contexts</li> <li>Handle errors gracefully: Catch and handle exceptions within your extractor methods</li> <li>Provide rich metadata: Include useful information about the extraction process in the result metadata</li> <li>Test with various inputs: Ensure your extractor works with a variety of file formats and edge cases</li> <li>Consider performance: For large files, implement streaming or chunking to avoid memory issues</li> <li>Document your extractors: Include clear documentation for your custom extractors</li> </ol>"},{"location":"advanced/custom-hooks/","title":"Custom Hooks","text":"<p>Kreuzberg allows you to customize the extraction process through validation and post-processing hooks.</p>"},{"location":"advanced/custom-hooks/#validation-hooks","title":"Validation Hooks","text":"<p>Validation hooks allow you to validate extraction results and raise errors if they don't meet your criteria.</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, ValidationError, ExtractionResult\n\n# Define a validation hook\ndef validate_content_length(result: ExtractionResult) -&gt; None:\n    \"\"\"Validate that the extracted content has a minimum length.\"\"\"\n    if len(result.content) &lt; 10:\n        raise ValidationError(\"Extracted content is too short (less than 10 characters)\")\n\n# Use the validation hook\nasync def extract_with_validation():\n    config = ExtractionConfig(validators=[validate_content_length])\n\n    result = await extract_file(\"document.pdf\", config=config)\n    return result\n</code></pre>"},{"location":"advanced/custom-hooks/#post-processing-hooks","title":"Post-Processing Hooks","text":"<p>Post-processing hooks allow you to modify the extraction result before it's returned.</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, ExtractionResult\n\n# Define a post-processing hook\ndef clean_whitespace(result: ExtractionResult) -&gt; ExtractionResult:\n    \"\"\"Clean up excessive whitespace in the extracted text.\"\"\"\n    import re\n\n    # Replace multiple spaces with a single space\n    cleaned_content = re.sub(r\"\\s+\", \" \", result.content)\n\n    # Replace multiple newlines with a single newline\n    cleaned_content = re.sub(r\"\\n+\", \"\\n\", cleaned_content)\n\n    # Create a new result with the cleaned content\n    return ExtractionResult(content=cleaned_content, mime_type=result.mime_type, metadata=result.metadata)\n\n# Use the post-processing hook\nasync def extract_with_post_processing():\n    config = ExtractionConfig(post_processing_hooks=[clean_whitespace])\n\n    result = await extract_file(\"document.pdf\", config=config)\n    return result\n</code></pre>"},{"location":"advanced/custom-hooks/#combining-multiple-hooks","title":"Combining Multiple Hooks","text":"<p>You can combine multiple validation and post-processing hooks:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, ExtractionResult, ValidationError\n\n# Define validation hooks\ndef validate_content_length(result: ExtractionResult) -&gt; None:\n    if len(result.content) &lt; 10:\n        raise ValidationError(\"Extracted content is too short\")\n\ndef validate_has_text(result: ExtractionResult) -&gt; None:\n    if not result.content.strip():\n        raise ValidationError(\"Extracted content is empty or contains only whitespace\")\n\n# Define post-processing hooks\ndef clean_whitespace(result: ExtractionResult) -&gt; ExtractionResult:\n    import re\n\n    cleaned_content = re.sub(r\"\\s+\", \" \", result.content)\n    cleaned_content = re.sub(r\"\\n+\", \"\\n\", cleaned_content)\n\n    return ExtractionResult(content=cleaned_content, mime_type=result.mime_type, metadata=result.metadata)\n\ndef normalize_text(result: ExtractionResult) -&gt; ExtractionResult:\n    \"\"\"Normalize text by converting to lowercase and removing special characters.\"\"\"\n    import re\n\n    # Convert to lowercase\n    normalized = result.content.lower()\n\n    # Remove special characters\n    normalized = re.sub(r\"[^\\w\\s]\", \"\", normalized)\n\n    return ExtractionResult(content=normalized, mime_type=result.mime_type, metadata=result.metadata)\n\n# Use multiple hooks\nasync def extract_with_multiple_hooks():\n    config = ExtractionConfig(\n        validators=[validate_content_length, validate_has_text], post_processing_hooks=[clean_whitespace, normalize_text]\n    )\n\n    result = await extract_file(\"document.pdf\", config=config)\n    return result\n</code></pre>"},{"location":"advanced/custom-hooks/#advanced-example-language-detection","title":"Advanced Example: Language Detection","text":"<p>Here's an example of using a post-processing hook to detect the language of extracted text:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, ExtractionResult\n\ndef detect_language(result: ExtractionResult) -&gt; ExtractionResult:\n    \"\"\"Detect the language of the extracted text and add it to metadata.\"\"\"\n    try:\n        # You need to install langdetect: pip install langdetect\n        from langdetect import detect\n\n        # Only detect if we have enough text\n        if len(result.content) &gt; 50:\n            language = detect(result.content)\n\n            # Create updated metadata with language information\n            updated_metadata = dict(result.metadata)\n            updated_metadata[\"detected_language\"] = language\n\n            return ExtractionResult(content=result.content, mime_type=result.mime_type, metadata=updated_metadata)\n    except Exception:\n        # If language detection fails, return the original result\n        pass\n\n    return result\n\nasync def extract_with_language_detection():\n    config = ExtractionConfig(post_processing_hooks=[detect_language])\n\n    result = await extract_file(\"document.pdf\", config=config)\n\n    if \"detected_language\" in result.metadata:\n        print(f\"Detected language: {result.metadata['detected_language']}\")\n\n    return result\n</code></pre>"},{"location":"advanced/custom-hooks/#best-practices","title":"Best Practices","text":"<ol> <li>Keep hooks simple: Each hook should perform a single, well-defined task</li> <li>Handle exceptions: Validation hooks should raise <code>ValidationError</code>, while post-processing hooks should handle their own exceptions</li> <li>Preserve metadata: When modifying content in post-processing hooks, make sure to preserve the original metadata</li> <li>Order matters: Post-processing hooks are applied in the order they are provided</li> <li>Be careful with mutations: Create new <code>ExtractionResult</code> objects rather than modifying the original</li> <li>Document your hooks: Include clear documentation for your custom hooks, especially if they're used across multiple projects</li> </ol>"},{"location":"advanced/error-handling/","title":"Error Handling","text":"<p>Kreuzberg provides specific exception types to help you handle different error scenarios during text extraction.</p>"},{"location":"advanced/error-handling/#exception-hierarchy","title":"Exception Hierarchy","text":"<p>All Kreuzberg exceptions inherit from the base <code>KreuzbergError</code> class:</p> <pre><code>KreuzbergError\n\u251c\u2500\u2500 MissingDependencyError\n\u251c\u2500\u2500 OCRError\n\u251c\u2500\u2500 ParsingError\n\u2514\u2500\u2500 ValidationError\n</code></pre>"},{"location":"advanced/error-handling/#handling-specific-exceptions","title":"Handling Specific Exceptions","text":""},{"location":"advanced/error-handling/#comprehensive-error-handling","title":"Comprehensive Error Handling","text":"<pre><code>from kreuzberg import extract_file\nfrom kreuzberg import KreuzbergError, MissingDependencyError, OCRError, ParsingError, ValidationError\n\nasync def safe_extract(path):\n    try:\n        result = await extract_file(path)\n        return result.content\n    except MissingDependencyError as e:\n        # Handle missing system dependencies (Tesseract, Pandoc)\n        print(f\"Missing dependency: {e}\")\n        print(\"Please install the required dependencies.\")\n        # You might want to provide installation instructions here\n    except OCRError as e:\n        # Handle OCR processing failures\n        print(f\"OCR processing failed: {e}\")\n        # You might want to retry with different OCR settings\n    except ParsingError as e:\n        # Handle document parsing failures\n        print(f\"Document parsing failed: {e}\")\n        # You might want to try a different approach or format\n    except ValidationError as e:\n        # Handle validation errors in configuration\n        print(f\"Validation error: {e}\")\n        # Fix the configuration issue\n    except KreuzbergError as e:\n        # Catch-all for any other Kreuzberg-specific errors\n        print(f\"Extraction error: {e}\")\n    except Exception as e:\n        # Handle unexpected errors\n        print(f\"Unexpected error: {e}\")\n\n    return None\n</code></pre>"},{"location":"advanced/error-handling/#simplified-error-handling","title":"Simplified Error Handling","text":"<p>For simpler applications, you can catch just the base <code>KreuzbergError</code>:</p> <pre><code>from kreuzberg import extract_file, KreuzbergError\n\nasync def simple_safe_extract(path):\n    try:\n        result = await extract_file(path)\n        return result.content\n    except KreuzbergError as e:\n        print(f\"Extraction failed: {e}\")\n        return None\n</code></pre>"},{"location":"advanced/error-handling/#common-error-scenarios","title":"Common Error Scenarios","text":""},{"location":"advanced/error-handling/#missing-dependencies","title":"Missing Dependencies","text":"<pre><code>try:\n    result = await extract_file(\"document.pdf\")\nexcept MissingDependencyError as e:\n    if \"tesseract\" in str(e).lower():\n        print(\"Tesseract OCR is not installed. Please install it:\")\n        print(\"  - Ubuntu: sudo apt-get install tesseract-ocr\")\n        print(\"  - macOS: brew install tesseract\")\n        print(\"  - Windows: choco install tesseract\")\n    elif \"pandoc\" in str(e).lower():\n        print(\"Pandoc is not installed. Please install it:\")\n        print(\"  - Ubuntu: sudo apt-get install pandoc\")\n        print(\"  - macOS: brew install pandoc\")\n        print(\"  - Windows: choco install pandoc\")\n</code></pre>"},{"location":"advanced/error-handling/#ocr-errors","title":"OCR Errors","text":"<pre><code>from kreuzberg import extract_file, OCRError, TesseractConfig, PSMMode\n\nasync def extract_with_fallback(path):\n    # Try with default settings\n    try:\n        result = await extract_file(path)\n        return result.content\n    except OCRError:\n        # Try with different OCR settings\n        try:\n            result = await extract_file(\n                path, force_ocr=True, ocr_config=TesseractConfig(psm=PSMMode.SINGLE_BLOCK, language=\"eng\")\n            )\n            return result.content\n        except OCRError as e:\n            print(f\"OCR failed with all attempts: {e}\")\n            return None\n</code></pre>"},{"location":"advanced/error-handling/#validation-errors","title":"Validation Errors","text":"<pre><code>from kreuzberg import extract_file, ValidationError, TesseractConfig\n\nasync def extract_with_validation_handling():\n    try:\n        # This will raise a ValidationError - incompatible config\n        result = await extract_file(\n            \"document.pdf\", ocr_backend=\"easyocr\", ocr_config=TesseractConfig(language=\"eng\")  # Wrong config type for easyocr\n        )\n    except ValidationError as e:\n        print(f\"Configuration error: {e}\")\n        # Fix the configuration\n        from kreuzberg import EasyOCRConfig\n\n        result = await extract_file(\n            \"document.pdf\", ocr_backend=\"easyocr\", ocr_config=EasyOCRConfig(language=\"en\")  # Correct config type\n        )\n\n    return result.content\n</code></pre>"},{"location":"advanced/error-handling/#best-practices","title":"Best Practices","text":"<ol> <li>Always use try/except: Wrap extraction calls in try/except blocks to handle potential errors gracefully</li> <li>Provide helpful error messages: Give users clear information about what went wrong and how to fix it</li> <li>Implement fallbacks: When possible, try alternative approaches when the primary method fails</li> <li>Log detailed error information: Include error details in logs for debugging</li> <li>Check dependencies upfront: Verify that required dependencies are installed before attempting extraction</li> </ol> <pre><code>import subprocess\nfrom kreuzberg import extract_file\n\ndef check_dependencies():\n    \"\"\"Check if required dependencies are installed.\"\"\"\n    missing = []\n\n    # Check for Tesseract\n    try:\n        subprocess.run([\"tesseract\", \"--version\"], capture_output=True, check=True)\n    except (subprocess.SubprocessError, FileNotFoundError):\n        missing.append(\"tesseract\")\n\n    # Check for Pandoc\n    try:\n        subprocess.run([\"pandoc\", \"--version\"], capture_output=True, check=True)\n    except (subprocess.SubprocessError, FileNotFoundError):\n        missing.append(\"pandoc\")\n\n    return missing\n\nasync def main():\n    # Check dependencies before extraction\n    missing_deps = check_dependencies()\n    if missing_deps:\n        print(f\"Missing dependencies: {', '.join(missing_deps)}\")\n        print(\"Please install them before continuing.\")\n        return\n\n    # Proceed with extraction\n    try:\n        result = await extract_file(\"document.pdf\")\n        print(result.content)\n    except Exception as e:\n        print(f\"Extraction failed: {e}\")\n</code></pre>"},{"location":"api-reference/","title":"API Reference","text":"<p>Detailed documentation for Kreuzberg's public API.</p>"},{"location":"api-reference/#core-components","title":"Core Components","text":"<ul> <li>Extraction Functions - Functions for text extraction (Guide)</li> <li>Types - Data structures for results and configuration (Guide)</li> <li>OCR Configuration - OCR engine settings (Guide)</li> <li>Extractor Registry - Document extractor management (Guide)</li> <li>Exceptions - Error handling (Examples)</li> </ul>"},{"location":"api-reference/#public-api","title":"Public API","text":"<p>All components documented in this section are exported directly from the <code>kreuzberg</code> package and can be imported as follows:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, TesseractConfig  # etc.\n</code></pre>"},{"location":"api-reference/#api-overview","title":"API Overview","text":"<p>Kreuzberg's API has four main components:</p> <ol> <li>Extraction Functions: Extract text from documents</li> <li>Configuration Objects: Control extraction behavior</li> <li>Result Objects: Contain extracted text and metadata</li> <li>OCR Backends: Pluggable OCR engines</li> </ol>"},{"location":"api-reference/#examples","title":"Examples","text":""},{"location":"api-reference/#async-api-recommended","title":"Async API (Recommended)","text":"<pre><code>from kreuzberg import extract_file, ExtractionConfig\n\n# Basic usage\nresult = await extract_file(\"document.pdf\")\n\n# With configuration\nresult = await extract_file(\"document.pdf\", config=ExtractionConfig(force_ocr=True))\n</code></pre>"},{"location":"api-reference/#sync-api","title":"Sync API","text":"<pre><code>from kreuzberg import extract_file_sync\n\n# Basic usage\nresult = extract_file_sync(\"document.pdf\")\n</code></pre>"},{"location":"api-reference/exceptions/","title":"Exceptions","text":"<p>Error types for handling different extraction failure scenarios.</p>"},{"location":"api-reference/exceptions/#kreuzbergerror","title":"KreuzbergError","text":"<p>The base exception class for all Kreuzberg-specific errors:</p>"},{"location":"api-reference/exceptions/#kreuzberg.KreuzbergError","title":"<code>kreuzberg.KreuzbergError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all Kreuzberg errors.</p> Source code in <code>kreuzberg/exceptions.py</code> <pre><code>class KreuzbergError(Exception):\n    \"\"\"Base exception for all Kreuzberg errors.\"\"\"\n\n    context: Any\n    \"\"\"The context of the error.\"\"\"\n\n    def __init__(self, message: str, *, context: Any = None) -&gt; None:\n        self.context = context\n        super().__init__(message)\n\n    def _serialize_context(self, obj: Any) -&gt; Any:\n        \"\"\"Recursively serialize context objects to ensure JSON compatibility.\"\"\"\n        if isinstance(obj, bytes):\n            return obj.decode(\"utf-8\", errors=\"replace\")\n        if isinstance(obj, dict):\n            return {k: self._serialize_context(v) for k, v in obj.items()}\n        if isinstance(obj, (list, tuple)):\n            return [self._serialize_context(x) for x in obj]\n        if isinstance(obj, Exception):\n            return {\n                \"type\": obj.__class__.__name__,\n                \"message\": str(obj),\n            }\n        return obj\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a string representation of the exception.\"\"\"\n        if self.context:\n            serialized_context = self._serialize_context(self.context)\n            ctx = f\"\\n\\nContext: {dumps(serialized_context)}\"\n        else:\n            ctx = \"\"\n\n        return f\"{self.__class__.__name__}: {super().__str__()}{ctx}\"\n</code></pre>"},{"location":"api-reference/exceptions/#kreuzberg.KreuzbergError-attributes","title":"Attributes","text":""},{"location":"api-reference/exceptions/#kreuzberg.KreuzbergError.context","title":"<code>context: Any = context</code>  <code>instance-attribute</code>","text":"<p>The context of the error.</p>"},{"location":"api-reference/exceptions/#kreuzberg.KreuzbergError-functions","title":"Functions","text":""},{"location":"api-reference/exceptions/#kreuzberg.KreuzbergError.__str__","title":"<code>__str__() -&gt; str</code>","text":"<p>Return a string representation of the exception.</p> Source code in <code>kreuzberg/exceptions.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a string representation of the exception.\"\"\"\n    if self.context:\n        serialized_context = self._serialize_context(self.context)\n        ctx = f\"\\n\\nContext: {dumps(serialized_context)}\"\n    else:\n        ctx = \"\"\n\n    return f\"{self.__class__.__name__}: {super().__str__()}{ctx}\"\n</code></pre>"},{"location":"api-reference/exceptions/#missingdependencyerror","title":"MissingDependencyError","text":"<p>Raised when a required dependency is not available:</p>"},{"location":"api-reference/exceptions/#kreuzberg.MissingDependencyError","title":"<code>kreuzberg.MissingDependencyError</code>","text":"<p>               Bases: <code>KreuzbergError</code></p> <p>Raised when a dependency is missing.</p> Source code in <code>kreuzberg/exceptions.py</code> <pre><code>class MissingDependencyError(KreuzbergError):\n    \"\"\"Raised when a dependency is missing.\"\"\"\n\n    @classmethod\n    def create_for_package(\n        cls, *, dependency_group: str, functionality: str, package_name: str\n    ) -&gt; MissingDependencyError:\n        \"\"\"Creates a MissingDependencyError for a specified package and functionality.\n\n        This class method generates an error message to notify users about a\n        missing package dependency required for specific functionality. The error\n        message includes details about the missing package and the optional\n        dependency group required for installation.\n\n        Args:\n            dependency_group: The name of the optional dependency group that includes\n                the required package.\n            functionality: The functionality that requires the missing package.\n            package_name: The name of the missing package.\n\n        Returns:\n            MissingDependencyError: A customized error indicating the missing\n            dependency and how to resolve it.\n        \"\"\"\n        return MissingDependencyError(\n            f\"The package '{package_name}' is required to use {functionality}. You can install using the provided optional dependency group by installing `kreuzberg['{dependency_group}']`.\"\n        )\n</code></pre>"},{"location":"api-reference/exceptions/#kreuzberg.MissingDependencyError-functions","title":"Functions","text":""},{"location":"api-reference/exceptions/#kreuzberg.MissingDependencyError.create_for_package","title":"<code>create_for_package(*, dependency_group: str, functionality: str, package_name: str) -&gt; MissingDependencyError</code>  <code>classmethod</code>","text":"<p>Creates a MissingDependencyError for a specified package and functionality.</p> <p>This class method generates an error message to notify users about a missing package dependency required for specific functionality. The error message includes details about the missing package and the optional dependency group required for installation.</p> PARAMETER DESCRIPTION <code>dependency_group</code> <p>The name of the optional dependency group that includes the required package.</p> <p> TYPE: <code>str</code> </p> <code>functionality</code> <p>The functionality that requires the missing package.</p> <p> TYPE: <code>str</code> </p> <code>package_name</code> <p>The name of the missing package.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>MissingDependencyError</code> <p>A customized error indicating the missing</p> <p> TYPE: <code>MissingDependencyError</code> </p> <code>MissingDependencyError</code> <p>dependency and how to resolve it.</p> Source code in <code>kreuzberg/exceptions.py</code> <pre><code>@classmethod\ndef create_for_package(\n    cls, *, dependency_group: str, functionality: str, package_name: str\n) -&gt; MissingDependencyError:\n    \"\"\"Creates a MissingDependencyError for a specified package and functionality.\n\n    This class method generates an error message to notify users about a\n    missing package dependency required for specific functionality. The error\n    message includes details about the missing package and the optional\n    dependency group required for installation.\n\n    Args:\n        dependency_group: The name of the optional dependency group that includes\n            the required package.\n        functionality: The functionality that requires the missing package.\n        package_name: The name of the missing package.\n\n    Returns:\n        MissingDependencyError: A customized error indicating the missing\n        dependency and how to resolve it.\n    \"\"\"\n    return MissingDependencyError(\n        f\"The package '{package_name}' is required to use {functionality}. You can install using the provided optional dependency group by installing `kreuzberg['{dependency_group}']`.\"\n    )\n</code></pre>"},{"location":"api-reference/exceptions/#ocrerror","title":"OCRError","text":"<p>Raised when OCR processing fails:</p>"},{"location":"api-reference/exceptions/#kreuzberg.OCRError","title":"<code>kreuzberg.OCRError</code>","text":"<p>               Bases: <code>KreuzbergError</code></p> <p>Raised when an OCR error occurs.</p> Source code in <code>kreuzberg/exceptions.py</code> <pre><code>class OCRError(KreuzbergError):\n    \"\"\"Raised when an OCR error occurs.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#parsingerror","title":"ParsingError","text":"<p>Raised when document parsing fails:</p>"},{"location":"api-reference/exceptions/#kreuzberg.ParsingError","title":"<code>kreuzberg.ParsingError</code>","text":"<p>               Bases: <code>KreuzbergError</code></p> <p>Raised when a parsing error occurs.</p> Source code in <code>kreuzberg/exceptions.py</code> <pre><code>class ParsingError(KreuzbergError):\n    \"\"\"Raised when a parsing error occurs.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#validationerror","title":"ValidationError","text":"<p>Raised when validation of extraction configuration or results fails:</p>"},{"location":"api-reference/exceptions/#kreuzberg.ValidationError","title":"<code>kreuzberg.ValidationError</code>","text":"<p>               Bases: <code>KreuzbergError</code></p> <p>Raised when a validation error occurs.</p> Source code in <code>kreuzberg/exceptions.py</code> <pre><code>class ValidationError(KreuzbergError):\n    \"\"\"Raised when a validation error occurs.\"\"\"\n</code></pre>"},{"location":"api-reference/extraction-functions/","title":"Extraction Functions","text":"<p>Kreuzberg provides both async and sync functions for text extraction. All functions accept an optional <code>ExtractionConfig</code> parameter for configuring the extraction process.</p>"},{"location":"api-reference/extraction-functions/#asynchronous-functions","title":"Asynchronous Functions","text":"<p>These functions return awaitable coroutines that must be awaited or run in an asyncio event loop.</p>"},{"location":"api-reference/extraction-functions/#extract_file","title":"extract_file","text":"<p>Extract text from a file path:</p>"},{"location":"api-reference/extraction-functions/#kreuzberg.extract_file","title":"<code>kreuzberg.extract_file(file_path: PathLike[str] | str, mime_type: str | None = None, config: ExtractionConfig = DEFAULT_CONFIG) -&gt; ExtractionResult</code>  <code>async</code>","text":"<p>Extract the textual content from a given file.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>The path to the file.</p> <p> TYPE: <code>PathLike[str] | str</code> </p> <code>mime_type</code> <p>The mime type of the content.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>config</code> <p>Extraction options object, defaults to the default object.</p> <p> TYPE: <code>ExtractionConfig</code> DEFAULT: <code>DEFAULT_CONFIG</code> </p> RETURNS DESCRIPTION <code>ExtractionResult</code> <p>The extracted content and the mime type of the content.</p> Source code in <code>kreuzberg/extraction.py</code> <pre><code>async def extract_file(\n    file_path: PathLike[str] | str, mime_type: str | None = None, config: ExtractionConfig = DEFAULT_CONFIG\n) -&gt; ExtractionResult:\n    \"\"\"Extract the textual content from a given file.\n\n    Args:\n        file_path: The path to the file.\n        mime_type: The mime type of the content.\n        config: Extraction options object, defaults to the default object.\n\n    Returns:\n        The extracted content and the mime type of the content.\n    \"\"\"\n    mime_type = validate_mime_type(file_path=file_path, mime_type=mime_type)\n    if extractor := ExtractorRegistry.get_extractor(mime_type=mime_type, config=config):\n        result = await extractor.extract_path_async(Path(file_path))\n    else:\n        result = ExtractionResult(\n            content=safe_decode(await anyio.Path(file_path).read_bytes()), chunks=[], mime_type=mime_type, metadata={}\n        )\n\n    return await _validate_and_post_process_async(result=result, config=config)\n</code></pre>"},{"location":"api-reference/extraction-functions/#extract_bytes","title":"extract_bytes","text":"<p>Extract text from raw bytes:</p>"},{"location":"api-reference/extraction-functions/#kreuzberg.extract_bytes","title":"<code>kreuzberg.extract_bytes(content: bytes, mime_type: str, config: ExtractionConfig = DEFAULT_CONFIG) -&gt; ExtractionResult</code>  <code>async</code>","text":"<p>Extract the textual content from a given byte string representing a file's contents.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to extract.</p> <p> TYPE: <code>bytes</code> </p> <code>mime_type</code> <p>The mime type of the content.</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>Extraction options object, defaults to the default object.</p> <p> TYPE: <code>ExtractionConfig</code> DEFAULT: <code>DEFAULT_CONFIG</code> </p> RETURNS DESCRIPTION <code>ExtractionResult</code> <p>The extracted content and the mime type of the content.</p> Source code in <code>kreuzberg/extraction.py</code> <pre><code>async def extract_bytes(content: bytes, mime_type: str, config: ExtractionConfig = DEFAULT_CONFIG) -&gt; ExtractionResult:\n    \"\"\"Extract the textual content from a given byte string representing a file's contents.\n\n    Args:\n        content: The content to extract.\n        mime_type: The mime type of the content.\n        config: Extraction options object, defaults to the default object.\n\n\n    Returns:\n        The extracted content and the mime type of the content.\n    \"\"\"\n    mime_type = validate_mime_type(mime_type=mime_type)\n    if extractor := ExtractorRegistry.get_extractor(mime_type=mime_type, config=config):\n        result = await extractor.extract_bytes_async(content)\n    else:\n        result = ExtractionResult(\n            content=safe_decode(content),\n            chunks=[],\n            mime_type=mime_type,\n            metadata={},\n        )\n\n    return await _validate_and_post_process_async(result=result, config=config)\n</code></pre>"},{"location":"api-reference/extraction-functions/#batch_extract_file","title":"batch_extract_file","text":"<p>Process multiple files concurrently:</p>"},{"location":"api-reference/extraction-functions/#kreuzberg.batch_extract_file","title":"<code>kreuzberg.batch_extract_file(file_paths: Sequence[PathLike[str] | str], config: ExtractionConfig = DEFAULT_CONFIG) -&gt; list[ExtractionResult]</code>  <code>async</code>","text":"<p>Extract text from multiple files concurrently.</p> PARAMETER DESCRIPTION <code>file_paths</code> <p>A sequence of paths to files to extract text from.</p> <p> TYPE: <code>Sequence[PathLike[str] | str]</code> </p> <code>config</code> <p>Extraction options object, defaults to the default object.</p> <p> TYPE: <code>ExtractionConfig</code> DEFAULT: <code>DEFAULT_CONFIG</code> </p> RETURNS DESCRIPTION <code>list[ExtractionResult]</code> <p>A list of extraction results in the same order as the input paths.</p> Source code in <code>kreuzberg/extraction.py</code> <pre><code>async def batch_extract_file(\n    file_paths: Sequence[PathLike[str] | str], config: ExtractionConfig = DEFAULT_CONFIG\n) -&gt; list[ExtractionResult]:\n    \"\"\"Extract text from multiple files concurrently.\n\n    Args:\n        file_paths: A sequence of paths to files to extract text from.\n        config: Extraction options object, defaults to the default object.\n\n    Returns:\n        A list of extraction results in the same order as the input paths.\n    \"\"\"\n    results = cast(\"list[ExtractionResult]\", ([None] * len(file_paths)))\n\n    async def _extract_file(path: PathLike[str] | str, index: int) -&gt; None:\n        result = await extract_file(\n            path,\n            None,\n            config,\n        )\n        results[index] = result\n\n    async with anyio.create_task_group() as tg:\n        for i, path in enumerate(file_paths):\n            tg.start_soon(_extract_file, path, i)\n\n    return results\n</code></pre>"},{"location":"api-reference/extraction-functions/#batch_extract_bytes","title":"batch_extract_bytes","text":"<p>Process multiple byte contents concurrently:</p>"},{"location":"api-reference/extraction-functions/#kreuzberg.batch_extract_bytes","title":"<code>kreuzberg.batch_extract_bytes(contents: Sequence[tuple[bytes, str]], config: ExtractionConfig = DEFAULT_CONFIG) -&gt; list[ExtractionResult]</code>  <code>async</code>","text":"<p>Extract text from multiple byte contents concurrently.</p> PARAMETER DESCRIPTION <code>contents</code> <p>A sequence of tuples containing (content, mime_type) pairs.</p> <p> TYPE: <code>Sequence[tuple[bytes, str]]</code> </p> <code>config</code> <p>Extraction options object, defaults to the default object.</p> <p> TYPE: <code>ExtractionConfig</code> DEFAULT: <code>DEFAULT_CONFIG</code> </p> RETURNS DESCRIPTION <code>list[ExtractionResult]</code> <p>A list of extraction results in the same order as the input contents.</p> Source code in <code>kreuzberg/extraction.py</code> <pre><code>async def batch_extract_bytes(\n    contents: Sequence[tuple[bytes, str]], config: ExtractionConfig = DEFAULT_CONFIG\n) -&gt; list[ExtractionResult]:\n    \"\"\"Extract text from multiple byte contents concurrently.\n\n    Args:\n        contents: A sequence of tuples containing (content, mime_type) pairs.\n        config: Extraction options object, defaults to the default object.\n\n    Returns:\n        A list of extraction results in the same order as the input contents.\n    \"\"\"\n    results = cast(\"list[ExtractionResult]\", [None] * len(contents))\n\n    async def _extract_bytes(content: bytes, mime_type: str, index: int) -&gt; None:\n        result = await extract_bytes(content, mime_type, config)\n        results[index] = result\n\n    async with anyio.create_task_group() as tg:\n        for i, (content, mime_type) in enumerate(contents):\n            tg.start_soon(_extract_bytes, content, mime_type, i)\n\n    return results\n</code></pre>"},{"location":"api-reference/extraction-functions/#synchronous-functions","title":"Synchronous Functions","text":"<p>These functions block until extraction is complete and are suitable for non-async contexts.</p>"},{"location":"api-reference/extraction-functions/#extract_file_sync","title":"extract_file_sync","text":"<p>Synchronous version of extract_file:</p>"},{"location":"api-reference/extraction-functions/#kreuzberg.extract_file_sync","title":"<code>kreuzberg.extract_file_sync(file_path: Path | str, mime_type: str | None = None, config: ExtractionConfig = DEFAULT_CONFIG) -&gt; ExtractionResult</code>","text":"<p>Synchronous version of extract_file.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>The path to the file.</p> <p> TYPE: <code>Path | str</code> </p> <code>mime_type</code> <p>The mime type of the content.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>config</code> <p>Extraction options object, defaults to the default object.</p> <p> TYPE: <code>ExtractionConfig</code> DEFAULT: <code>DEFAULT_CONFIG</code> </p> RETURNS DESCRIPTION <code>ExtractionResult</code> <p>The extracted content and the mime type of the content.</p> Source code in <code>kreuzberg/extraction.py</code> <pre><code>def extract_file_sync(\n    file_path: Path | str, mime_type: str | None = None, config: ExtractionConfig = DEFAULT_CONFIG\n) -&gt; ExtractionResult:\n    \"\"\"Synchronous version of extract_file.\n\n    Args:\n        file_path: The path to the file.\n        mime_type: The mime type of the content.\n        config: Extraction options object, defaults to the default object.\n\n    Returns:\n        The extracted content and the mime type of the content.\n    \"\"\"\n    mime_type = validate_mime_type(file_path=file_path, mime_type=mime_type)\n    if extractor := ExtractorRegistry.get_extractor(mime_type=mime_type, config=config):\n        result = extractor.extract_path_sync(Path(file_path))\n    else:\n        result = ExtractionResult(\n            content=Path(file_path).read_text(),\n            chunks=[],\n            mime_type=mime_type,\n            metadata={},\n        )\n    return _validate_and_post_process_sync(result=result, config=config)\n</code></pre>"},{"location":"api-reference/extraction-functions/#extract_bytes_sync","title":"extract_bytes_sync","text":"<p>Synchronous version of extract_bytes:</p>"},{"location":"api-reference/extraction-functions/#kreuzberg.extract_bytes_sync","title":"<code>kreuzberg.extract_bytes_sync(content: bytes, mime_type: str, config: ExtractionConfig = DEFAULT_CONFIG) -&gt; ExtractionResult</code>","text":"<p>Synchronous version of extract_bytes.</p> PARAMETER DESCRIPTION <code>content</code> <p>The content to extract.</p> <p> TYPE: <code>bytes</code> </p> <code>mime_type</code> <p>The mime type of the content.</p> <p> TYPE: <code>str</code> </p> <code>config</code> <p>Extraction options object, defaults to the default object.</p> <p> TYPE: <code>ExtractionConfig</code> DEFAULT: <code>DEFAULT_CONFIG</code> </p> RETURNS DESCRIPTION <code>ExtractionResult</code> <p>The extracted content and the mime type of the content.</p> Source code in <code>kreuzberg/extraction.py</code> <pre><code>def extract_bytes_sync(content: bytes, mime_type: str, config: ExtractionConfig = DEFAULT_CONFIG) -&gt; ExtractionResult:\n    \"\"\"Synchronous version of extract_bytes.\n\n    Args:\n        content: The content to extract.\n        mime_type: The mime type of the content.\n        config: Extraction options object, defaults to the default object.\n\n    Returns:\n        The extracted content and the mime type of the content.\n    \"\"\"\n    mime_type = validate_mime_type(mime_type=mime_type)\n    if extractor := ExtractorRegistry.get_extractor(mime_type=mime_type, config=config):\n        result = extractor.extract_bytes_sync(content)\n    else:\n        result = ExtractionResult(\n            content=safe_decode(content),\n            chunks=[],\n            mime_type=mime_type,\n            metadata={},\n        )\n\n    return _validate_and_post_process_sync(result=result, config=config)\n</code></pre>"},{"location":"api-reference/extraction-functions/#batch_extract_file_sync","title":"batch_extract_file_sync","text":"<p>Synchronous version of batch_extract_file:</p>"},{"location":"api-reference/extraction-functions/#kreuzberg.batch_extract_file_sync","title":"<code>kreuzberg.batch_extract_file_sync(file_paths: Sequence[PathLike[str] | str], config: ExtractionConfig = DEFAULT_CONFIG) -&gt; list[ExtractionResult]</code>","text":"<p>Synchronous version of batch_extract_file.</p> PARAMETER DESCRIPTION <code>file_paths</code> <p>A sequence of paths to files to extract text from.</p> <p> TYPE: <code>Sequence[PathLike[str] | str]</code> </p> <code>config</code> <p>Extraction options object, defaults to the default object.</p> <p> TYPE: <code>ExtractionConfig</code> DEFAULT: <code>DEFAULT_CONFIG</code> </p> RETURNS DESCRIPTION <code>list[ExtractionResult]</code> <p>A list of extraction results in the same order as the input paths.</p> Source code in <code>kreuzberg/extraction.py</code> <pre><code>def batch_extract_file_sync(\n    file_paths: Sequence[PathLike[str] | str], config: ExtractionConfig = DEFAULT_CONFIG\n) -&gt; list[ExtractionResult]:\n    \"\"\"Synchronous version of batch_extract_file.\n\n    Args:\n        file_paths: A sequence of paths to files to extract text from.\n        config: Extraction options object, defaults to the default object.\n\n    Returns:\n        A list of extraction results in the same order as the input paths.\n    \"\"\"\n    return [extract_file_sync(file_path=Path(file_path), mime_type=None, config=config) for file_path in file_paths]\n</code></pre>"},{"location":"api-reference/extraction-functions/#batch_extract_bytes_sync","title":"batch_extract_bytes_sync","text":"<p>Synchronous version of batch_extract_bytes:</p>"},{"location":"api-reference/extraction-functions/#kreuzberg.batch_extract_bytes_sync","title":"<code>kreuzberg.batch_extract_bytes_sync(contents: Sequence[tuple[bytes, str]], config: ExtractionConfig = DEFAULT_CONFIG) -&gt; list[ExtractionResult]</code>","text":"<p>Synchronous version of batch_extract_bytes.</p> PARAMETER DESCRIPTION <code>contents</code> <p>A sequence of tuples containing (content, mime_type) pairs.</p> <p> TYPE: <code>Sequence[tuple[bytes, str]]</code> </p> <code>config</code> <p>Extraction options object, defaults to the default object.</p> <p> TYPE: <code>ExtractionConfig</code> DEFAULT: <code>DEFAULT_CONFIG</code> </p> RETURNS DESCRIPTION <code>list[ExtractionResult]</code> <p>A list of extraction results in the same order as the input contents.</p> Source code in <code>kreuzberg/extraction.py</code> <pre><code>def batch_extract_bytes_sync(\n    contents: Sequence[tuple[bytes, str]], config: ExtractionConfig = DEFAULT_CONFIG\n) -&gt; list[ExtractionResult]:\n    \"\"\"Synchronous version of batch_extract_bytes.\n\n    Args:\n        contents: A sequence of tuples containing (content, mime_type) pairs.\n        config: Extraction options object, defaults to the default object.\n\n    Returns:\n        A list of extraction results in the same order as the input contents.\n    \"\"\"\n    return [extract_bytes_sync(content=content, mime_type=mime_type, config=config) for content, mime_type in contents]\n</code></pre>"},{"location":"api-reference/extractor-registry/","title":"Extractor Registry","text":"<p>The <code>ExtractorRegistry</code> manages document extractors and allows custom extractor registration.</p>"},{"location":"api-reference/extractor-registry/#kreuzberg.ExtractorRegistry","title":"<code>kreuzberg.ExtractorRegistry</code>","text":"<p>Manages extractors for different MIME types and their configurations.</p> <p>This class provides functionality to register, unregister, and retrieve extractors based on MIME types. It supports both synchronous and asynchronous operations for managing extractors. A default set of extractors is also maintained alongside user-registered extractors.</p> Source code in <code>kreuzberg/_registry.py</code> <pre><code>class ExtractorRegistry:\n    \"\"\"Manages extractors for different MIME types and their configurations.\n\n    This class provides functionality to register, unregister, and retrieve\n    extractors based on MIME types. It supports both synchronous and asynchronous\n    operations for managing extractors. A default set of extractors is also\n    maintained alongside user-registered extractors.\n    \"\"\"\n\n    _default_extractors: ClassVar[list[type[Extractor]]] = [\n        PDFExtractor,\n        OfficeDocumentExtractor,\n        PresentationExtractor,\n        SpreadSheetExtractor,\n        HTMLExtractor,\n        MarkdownExtractor,\n        ImageExtractor,\n        BibliographyExtractor,\n        EbookExtractor,\n        LaTeXExtractor,\n        MiscFormatExtractor,\n        StructuredTextExtractor,\n        TabularDataExtractor,\n        XMLBasedExtractor,\n    ]\n    _registered_extractors: ClassVar[list[type[Extractor]]] = []\n\n    @classmethod\n    @lru_cache\n    def get_extractor(cls, mime_type: str | None, config: ExtractionConfig) -&gt; Extractor | None:\n        \"\"\"Gets the extractor for the mimetype.\n\n        Args:\n            mime_type: The mime type of the content.\n            config: Extraction options object, defaults to the default object.\n\n        Returns:\n            The extractor\n        \"\"\"\n        extractors: list[type[Extractor]] = [\n            *cls._registered_extractors,\n            *cls._default_extractors,\n        ]\n        if mime_type:\n            for extractor in extractors:\n                if extractor.supports_mimetype(mime_type):\n                    return extractor(mime_type=mime_type, config=config)\n\n        return None\n\n    @classmethod\n    def add_extractor(cls, extractor: type[Extractor]) -&gt; None:\n        \"\"\"Add an extractor to the registry.\n\n        Note:\n            Extractors are tried in the order they are added: first added, first tried.\n\n        Args:\n            extractor: The extractor to add.\n\n        Returns:\n            None\n        \"\"\"\n        cls._registered_extractors.append(extractor)\n        cls.get_extractor.cache_clear()\n\n    @classmethod\n    def remove_extractor(cls, extractor: type[Extractor]) -&gt; None:\n        \"\"\"Remove an extractor from the registry.\n\n        Args:\n            extractor: The extractor to remove.\n\n        Returns:\n            None\n        \"\"\"\n        try:\n            cls._registered_extractors.remove(extractor)\n            cls.get_extractor.cache_clear()\n        except ValueError:\n            pass\n</code></pre>"},{"location":"api-reference/extractor-registry/#kreuzberg.ExtractorRegistry-functions","title":"Functions","text":""},{"location":"api-reference/extractor-registry/#kreuzberg.ExtractorRegistry.add_extractor","title":"<code>add_extractor(extractor: type[Extractor]) -&gt; None</code>  <code>classmethod</code>","text":"<p>Add an extractor to the registry.</p> Note <p>Extractors are tried in the order they are added: first added, first tried.</p> PARAMETER DESCRIPTION <code>extractor</code> <p>The extractor to add.</p> <p> TYPE: <code>type[Extractor]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>kreuzberg/_registry.py</code> <pre><code>@classmethod\ndef add_extractor(cls, extractor: type[Extractor]) -&gt; None:\n    \"\"\"Add an extractor to the registry.\n\n    Note:\n        Extractors are tried in the order they are added: first added, first tried.\n\n    Args:\n        extractor: The extractor to add.\n\n    Returns:\n        None\n    \"\"\"\n    cls._registered_extractors.append(extractor)\n    cls.get_extractor.cache_clear()\n</code></pre>"},{"location":"api-reference/extractor-registry/#kreuzberg.ExtractorRegistry.get_extractor","title":"<code>get_extractor(mime_type: str | None, config: ExtractionConfig) -&gt; Extractor | None</code>  <code>cached</code> <code>classmethod</code>","text":"<p>Gets the extractor for the mimetype.</p> PARAMETER DESCRIPTION <code>mime_type</code> <p>The mime type of the content.</p> <p> TYPE: <code>str | None</code> </p> <code>config</code> <p>Extraction options object, defaults to the default object.</p> <p> TYPE: <code>ExtractionConfig</code> </p> RETURNS DESCRIPTION <code>Extractor | None</code> <p>The extractor</p> Source code in <code>kreuzberg/_registry.py</code> <pre><code>@classmethod\n@lru_cache\ndef get_extractor(cls, mime_type: str | None, config: ExtractionConfig) -&gt; Extractor | None:\n    \"\"\"Gets the extractor for the mimetype.\n\n    Args:\n        mime_type: The mime type of the content.\n        config: Extraction options object, defaults to the default object.\n\n    Returns:\n        The extractor\n    \"\"\"\n    extractors: list[type[Extractor]] = [\n        *cls._registered_extractors,\n        *cls._default_extractors,\n    ]\n    if mime_type:\n        for extractor in extractors:\n            if extractor.supports_mimetype(mime_type):\n                return extractor(mime_type=mime_type, config=config)\n\n    return None\n</code></pre>"},{"location":"api-reference/extractor-registry/#kreuzberg.ExtractorRegistry.remove_extractor","title":"<code>remove_extractor(extractor: type[Extractor]) -&gt; None</code>  <code>classmethod</code>","text":"<p>Remove an extractor from the registry.</p> PARAMETER DESCRIPTION <code>extractor</code> <p>The extractor to remove.</p> <p> TYPE: <code>type[Extractor]</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>kreuzberg/_registry.py</code> <pre><code>@classmethod\ndef remove_extractor(cls, extractor: type[Extractor]) -&gt; None:\n    \"\"\"Remove an extractor from the registry.\n\n    Args:\n        extractor: The extractor to remove.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        cls._registered_extractors.remove(extractor)\n        cls.get_extractor.cache_clear()\n    except ValueError:\n        pass\n</code></pre>"},{"location":"api-reference/ocr-configuration/","title":"OCR Configuration","text":"<p>Configuration classes for the supported OCR engines.</p>"},{"location":"api-reference/ocr-configuration/#tesseractconfig","title":"TesseractConfig","text":"<p>Default OCR engine configuration:</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig","title":"<code>kreuzberg.TesseractConfig</code>  <code>dataclass</code>","text":"<p>Configuration options for Tesseract OCR engine.</p> Source code in <code>kreuzberg/_ocr/_tesseract.py</code> <pre><code>@dataclass(unsafe_hash=True, frozen=True)\nclass TesseractConfig:\n    \"\"\"Configuration options for Tesseract OCR engine.\"\"\"\n\n    classify_use_pre_adapted_templates: bool = True\n    \"\"\"Whether to use pre-adapted templates during classification to improve recognition accuracy.\"\"\"\n    language: str = \"eng\"\n    \"\"\"Language code to use for OCR.\n    Examples:\n            -   'eng' for English\n            -   'deu' for German\n            -    multiple languages combined with '+', e.g. 'eng+deu')\n    \"\"\"\n    language_model_ngram_on: bool = True\n    \"\"\"Enable or disable the use of n-gram-based language models for improved text recognition.\"\"\"\n    psm: PSMMode = PSMMode.AUTO\n    \"\"\"Page segmentation mode (PSM) to guide Tesseract on how to segment the image (e.g., single block, single line).\"\"\"\n    tessedit_dont_blkrej_good_wds: bool = True\n    \"\"\"If True, prevents block rejection of words identified as good, improving text output quality.\"\"\"\n    tessedit_dont_rowrej_good_wds: bool = True\n    \"\"\"If True, prevents row rejection of words identified as good, avoiding unnecessary omissions.\"\"\"\n    tessedit_enable_dict_correction: bool = True\n    \"\"\"Enable or disable dictionary-based correction for recognized text to improve word accuracy.\"\"\"\n    tessedit_use_primary_params_model: bool = True\n    \"\"\"If True, forces the use of the primary parameters model for text recognition.\"\"\"\n    textord_space_size_is_variable: bool = True\n    \"\"\"Allow variable spacing between words, useful for text with irregular spacing.\"\"\"\n    thresholding_method: bool = False\n    \"\"\"Enable or disable specific thresholding methods during image preprocessing for better OCR accuracy.\"\"\"\n</code></pre>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.classify_use_pre_adapted_templates","title":"<code>classify_use_pre_adapted_templates: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use pre-adapted templates during classification to improve recognition accuracy.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.language","title":"<code>language: str = 'eng'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Language code to use for OCR. Examples:         -   'eng' for English         -   'deu' for German         -    multiple languages combined with '+', e.g. 'eng+deu')</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.language_model_ngram_on","title":"<code>language_model_ngram_on: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable or disable the use of n-gram-based language models for improved text recognition.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.psm","title":"<code>psm: PSMMode = PSMMode.AUTO</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Page segmentation mode (PSM) to guide Tesseract on how to segment the image (e.g., single block, single line).</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.tessedit_dont_blkrej_good_wds","title":"<code>tessedit_dont_blkrej_good_wds: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, prevents block rejection of words identified as good, improving text output quality.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.tessedit_dont_rowrej_good_wds","title":"<code>tessedit_dont_rowrej_good_wds: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, prevents row rejection of words identified as good, avoiding unnecessary omissions.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.tessedit_enable_dict_correction","title":"<code>tessedit_enable_dict_correction: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable or disable dictionary-based correction for recognized text to improve word accuracy.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.tessedit_use_primary_params_model","title":"<code>tessedit_use_primary_params_model: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, forces the use of the primary parameters model for text recognition.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.textord_space_size_is_variable","title":"<code>textord_space_size_is_variable: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Allow variable spacing between words, useful for text with irregular spacing.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.TesseractConfig.thresholding_method","title":"<code>thresholding_method: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable or disable specific thresholding methods during image preprocessing for better OCR accuracy.</p>"},{"location":"api-reference/ocr-configuration/#psmmode","title":"PSMMode","text":"<p>Page Segmentation Mode options for Tesseract:</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode","title":"<code>kreuzberg.PSMMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for Tesseract Page Segmentation Modes (PSM) with human-readable values.</p> Source code in <code>kreuzberg/_ocr/_tesseract.py</code> <pre><code>class PSMMode(Enum):\n    \"\"\"Enum for Tesseract Page Segmentation Modes (PSM) with human-readable values.\"\"\"\n\n    OSD_ONLY = 0\n    \"\"\"Orientation and script detection only.\"\"\"\n    AUTO_OSD = 1\n    \"\"\"Automatic page segmentation with orientation and script detection.\"\"\"\n    AUTO_ONLY = 2\n    \"\"\"Automatic page segmentation without OSD.\"\"\"\n    AUTO = 3\n    \"\"\"Fully automatic page segmentation (default).\"\"\"\n    SINGLE_COLUMN = 4\n    \"\"\"Assume a single column of text.\"\"\"\n    SINGLE_BLOCK_VERTICAL = 5\n    \"\"\"Assume a single uniform block of vertically aligned text.\"\"\"\n    SINGLE_BLOCK = 6\n    \"\"\"Assume a single uniform block of text.\"\"\"\n    SINGLE_LINE = 7\n    \"\"\"Treat the image as a single text line.\"\"\"\n    SINGLE_WORD = 8\n    \"\"\"Treat the image as a single word.\"\"\"\n    CIRCLE_WORD = 9\n    \"\"\"Treat the image as a single word in a circle.\"\"\"\n    SINGLE_CHAR = 10\n    \"\"\"Treat the image as a single character.\"\"\"\n</code></pre>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode-attributes","title":"Attributes","text":""},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.AUTO","title":"<code>AUTO = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fully automatic page segmentation (default).</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.AUTO_ONLY","title":"<code>AUTO_ONLY = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Automatic page segmentation without OSD.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.AUTO_OSD","title":"<code>AUTO_OSD = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Automatic page segmentation with orientation and script detection.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.CIRCLE_WORD","title":"<code>CIRCLE_WORD = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Treat the image as a single word in a circle.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.OSD_ONLY","title":"<code>OSD_ONLY = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Orientation and script detection only.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.SINGLE_BLOCK","title":"<code>SINGLE_BLOCK = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Assume a single uniform block of text.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.SINGLE_BLOCK_VERTICAL","title":"<code>SINGLE_BLOCK_VERTICAL = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Assume a single uniform block of vertically aligned text.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.SINGLE_CHAR","title":"<code>SINGLE_CHAR = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Treat the image as a single character.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.SINGLE_COLUMN","title":"<code>SINGLE_COLUMN = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Assume a single column of text.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.SINGLE_LINE","title":"<code>SINGLE_LINE = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Treat the image as a single text line.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PSMMode.SINGLE_WORD","title":"<code>SINGLE_WORD = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Treat the image as a single word.</p>"},{"location":"api-reference/ocr-configuration/#easyocrconfig","title":"EasyOCRConfig","text":"<p>Configuration for the EasyOCR engine:</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig","title":"<code>kreuzberg.EasyOCRConfig</code>  <code>dataclass</code>","text":"<p>Configuration options for EasyOCR.</p> Source code in <code>kreuzberg/_ocr/_easyocr.py</code> <pre><code>@dataclass(unsafe_hash=True, frozen=True)\nclass EasyOCRConfig:\n    \"\"\"Configuration options for EasyOCR.\"\"\"\n\n    add_margin: float = 0.1\n    \"\"\"Extend bounding boxes in all directions.\"\"\"\n    adjust_contrast: float = 0.5\n    \"\"\"Target contrast level for low contrast text.\"\"\"\n    beam_width: int = 5\n    \"\"\"Beam width for beam search in recognition.\"\"\"\n    canvas_size: int = 2560\n    \"\"\"Maximum image dimension for detection.\"\"\"\n    contrast_ths: float = 0.1\n    \"\"\"Contrast threshold for preprocessing.\"\"\"\n    decoder: Literal[\"greedy\", \"beamsearch\", \"wordbeamsearch\"] = \"greedy\"\n    \"\"\"Decoder method. Options: 'greedy', 'beamsearch', 'wordbeamsearch'.\"\"\"\n    height_ths: float = 0.5\n    \"\"\"Maximum difference in box height for merging.\"\"\"\n    language: str | list[str] = \"en\"\n    \"\"\"Language or languages to use for OCR.\"\"\"\n    link_threshold: float = 0.4\n    \"\"\"Link confidence threshold.\"\"\"\n    low_text: float = 0.4\n    \"\"\"Text low-bound score.\"\"\"\n    mag_ratio: float = 1.0\n    \"\"\"Image magnification ratio.\"\"\"\n    min_size: int = 10\n    \"\"\"Minimum text box size in pixels.\"\"\"\n    rotation_info: list[int] | None = None\n    \"\"\"List of angles to try for detection.\"\"\"\n    slope_ths: float = 0.1\n    \"\"\"Maximum slope for merging text boxes.\"\"\"\n    text_threshold: float = 0.7\n    \"\"\"Text confidence threshold.\"\"\"\n    use_gpu: bool = False\n    \"\"\"Whether to use GPU for inference.\"\"\"\n    width_ths: float = 0.5\n    \"\"\"Maximum horizontal distance for merging boxes.\"\"\"\n    x_ths: float = 1.0\n    \"\"\"Maximum horizontal distance for paragraph merging.\"\"\"\n    y_ths: float = 0.5\n    \"\"\"Maximum vertical distance for paragraph merging.\"\"\"\n    ycenter_ths: float = 0.5\n    \"\"\"Maximum shift in y direction for merging.\"\"\"\n</code></pre>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.add_margin","title":"<code>add_margin: float = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extend bounding boxes in all directions.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.adjust_contrast","title":"<code>adjust_contrast: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target contrast level for low contrast text.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.beam_width","title":"<code>beam_width: int = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Beam width for beam search in recognition.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.canvas_size","title":"<code>canvas_size: int = 2560</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum image dimension for detection.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.contrast_ths","title":"<code>contrast_ths: float = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Contrast threshold for preprocessing.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.decoder","title":"<code>decoder: Literal['greedy', 'beamsearch', 'wordbeamsearch'] = 'greedy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Decoder method. Options: 'greedy', 'beamsearch', 'wordbeamsearch'.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.height_ths","title":"<code>height_ths: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum difference in box height for merging.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.language","title":"<code>language: str | list[str] = 'en'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Language or languages to use for OCR.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.link_threshold","title":"<code>link_threshold: float = 0.4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Link confidence threshold.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.low_text","title":"<code>low_text: float = 0.4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Text low-bound score.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.mag_ratio","title":"<code>mag_ratio: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Image magnification ratio.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.min_size","title":"<code>min_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Minimum text box size in pixels.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.rotation_info","title":"<code>rotation_info: list[int] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of angles to try for detection.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.slope_ths","title":"<code>slope_ths: float = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum slope for merging text boxes.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.text_threshold","title":"<code>text_threshold: float = 0.7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Text confidence threshold.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.use_gpu","title":"<code>use_gpu: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use GPU for inference.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.width_ths","title":"<code>width_ths: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum horizontal distance for merging boxes.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.x_ths","title":"<code>x_ths: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum horizontal distance for paragraph merging.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.y_ths","title":"<code>y_ths: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum vertical distance for paragraph merging.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.EasyOCRConfig.ycenter_ths","title":"<code>ycenter_ths: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum shift in y direction for merging.</p>"},{"location":"api-reference/ocr-configuration/#paddleocrconfig","title":"PaddleOCRConfig","text":"<p>Configuration for the PaddleOCR engine:</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig","title":"<code>kreuzberg.PaddleOCRConfig</code>  <code>dataclass</code>","text":"<p>Configuration options for PaddleOCR.</p> <p>This TypedDict provides type hints and documentation for all PaddleOCR parameters.</p> Source code in <code>kreuzberg/_ocr/_paddleocr.py</code> <pre><code>@dataclass(unsafe_hash=True, frozen=True)\nclass PaddleOCRConfig:\n    \"\"\"Configuration options for PaddleOCR.\n\n    This TypedDict provides type hints and documentation for all PaddleOCR parameters.\n    \"\"\"\n\n    cls_image_shape: str = \"3,48,192\"\n    \"\"\"Image shape for classification algorithm in format 'channels,height,width'.\"\"\"\n    det_algorithm: Literal[\"DB\", \"EAST\", \"SAST\", \"PSE\", \"FCE\", \"PAN\", \"CT\", \"DB++\", \"Layout\"] = \"DB\"\n    \"\"\"Detection algorithm.\"\"\"\n    det_db_box_thresh: float = 0.5\n    \"\"\"Score threshold for detected boxes. Boxes below this value are discarded.\"\"\"\n    det_db_thresh: float = 0.3\n    \"\"\"Binarization threshold for DB output map.\"\"\"\n    det_db_unclip_ratio: float = 2.0\n    \"\"\"Expansion ratio for detected text boxes.\"\"\"\n    det_east_cover_thresh: float = 0.1\n    \"\"\"Score threshold for EAST output boxes.\"\"\"\n    det_east_nms_thresh: float = 0.2\n    \"\"\"NMS threshold for EAST model output boxes.\"\"\"\n    det_east_score_thresh: float = 0.8\n    \"\"\"Binarization threshold for EAST output map.\"\"\"\n    det_max_side_len: int = 960\n    \"\"\"Maximum size of image long side. Images exceeding this will be proportionally resized.\"\"\"\n    drop_score: float = 0.5\n    \"\"\"Filter recognition results by confidence score. Results below this are discarded.\"\"\"\n    enable_mkldnn: bool = False\n    \"\"\"Whether to enable MKL-DNN acceleration (Intel CPU only).\"\"\"\n    gpu_mem: int = 8000\n    \"\"\"GPU memory size (in MB) to use for initialization.\"\"\"\n    language: str = \"en\"\n    \"\"\"Language to use for OCR.\"\"\"\n    max_text_length: int = 25\n    \"\"\"Maximum text length that the recognition algorithm can recognize.\"\"\"\n    rec: bool = True\n    \"\"\"Enable text recognition when using the ocr() function.\"\"\"\n    rec_algorithm: Literal[\n        \"CRNN\",\n        \"SRN\",\n        \"NRTR\",\n        \"SAR\",\n        \"SEED\",\n        \"SVTR\",\n        \"SVTR_LCNet\",\n        \"ViTSTR\",\n        \"ABINet\",\n        \"VisionLAN\",\n        \"SPIN\",\n        \"RobustScanner\",\n        \"RFL\",\n    ] = \"CRNN\"\n    \"\"\"Recognition algorithm.\"\"\"\n    rec_image_shape: str = \"3,32,320\"\n    \"\"\"Image shape for recognition algorithm in format 'channels,height,width'.\"\"\"\n    table: bool = True\n    \"\"\"Whether to enable table recognition.\"\"\"\n    use_angle_cls: bool = True\n    \"\"\"Whether to use text orientation classification model.\"\"\"\n    use_gpu: bool = False\n    \"\"\"Whether to use GPU for inference. Requires installing the paddlepaddle-gpu package\"\"\"\n    use_space_char: bool = True\n    \"\"\"Whether to recognize spaces.\"\"\"\n    use_zero_copy_run: bool = False\n    \"\"\"Whether to enable zero_copy_run for inference optimization.\"\"\"\n</code></pre>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.cls_image_shape","title":"<code>cls_image_shape: str = '3,48,192'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Image shape for classification algorithm in format 'channels,height,width'.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.det_algorithm","title":"<code>det_algorithm: Literal['DB', 'EAST', 'SAST', 'PSE', 'FCE', 'PAN', 'CT', 'DB++', 'Layout'] = 'DB'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Detection algorithm.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.det_db_box_thresh","title":"<code>det_db_box_thresh: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Score threshold for detected boxes. Boxes below this value are discarded.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.det_db_thresh","title":"<code>det_db_thresh: float = 0.3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Binarization threshold for DB output map.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.det_db_unclip_ratio","title":"<code>det_db_unclip_ratio: float = 2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expansion ratio for detected text boxes.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.det_east_cover_thresh","title":"<code>det_east_cover_thresh: float = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Score threshold for EAST output boxes.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.det_east_nms_thresh","title":"<code>det_east_nms_thresh: float = 0.2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NMS threshold for EAST model output boxes.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.det_east_score_thresh","title":"<code>det_east_score_thresh: float = 0.8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Binarization threshold for EAST output map.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.det_max_side_len","title":"<code>det_max_side_len: int = 960</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum size of image long side. Images exceeding this will be proportionally resized.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.drop_score","title":"<code>drop_score: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Filter recognition results by confidence score. Results below this are discarded.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.enable_mkldnn","title":"<code>enable_mkldnn: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to enable MKL-DNN acceleration (Intel CPU only).</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.gpu_mem","title":"<code>gpu_mem: int = 8000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>GPU memory size (in MB) to use for initialization.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.language","title":"<code>language: str = 'en'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Language to use for OCR.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.max_text_length","title":"<code>max_text_length: int = 25</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum text length that the recognition algorithm can recognize.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.rec","title":"<code>rec: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable text recognition when using the ocr() function.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.rec_algorithm","title":"<code>rec_algorithm: Literal['CRNN', 'SRN', 'NRTR', 'SAR', 'SEED', 'SVTR', 'SVTR_LCNet', 'ViTSTR', 'ABINet', 'VisionLAN', 'SPIN', 'RobustScanner', 'RFL'] = 'CRNN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Recognition algorithm.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.rec_image_shape","title":"<code>rec_image_shape: str = '3,32,320'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Image shape for recognition algorithm in format 'channels,height,width'.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.table","title":"<code>table: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to enable table recognition.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.use_angle_cls","title":"<code>use_angle_cls: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use text orientation classification model.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.use_gpu","title":"<code>use_gpu: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use GPU for inference. Requires installing the paddlepaddle-gpu package</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.use_space_char","title":"<code>use_space_char: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to recognize spaces.</p>"},{"location":"api-reference/ocr-configuration/#kreuzberg.PaddleOCRConfig.use_zero_copy_run","title":"<code>use_zero_copy_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to enable zero_copy_run for inference optimization.</p>"},{"location":"api-reference/types/","title":"Types","text":"<p>Core data structures for extraction results, configuration, and metadata.</p>"},{"location":"api-reference/types/#extractionresult","title":"ExtractionResult","text":"<p>The result of a file extraction, containing the extracted text, MIME type, metadata, and table data:</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionResult","title":"<code>kreuzberg.ExtractionResult</code>  <code>dataclass</code>","text":"<p>The result of a file extraction.</p> Source code in <code>kreuzberg/_types.py</code> <pre><code>@dataclass\nclass ExtractionResult:\n    \"\"\"The result of a file extraction.\"\"\"\n\n    content: str\n    \"\"\"The extracted content.\"\"\"\n    mime_type: str\n    \"\"\"The mime type of the extracted content. Is either text/plain or text/markdown.\"\"\"\n    metadata: Metadata\n    \"\"\"The metadata of the content.\"\"\"\n    tables: list[TableData] = field(default_factory=list)\n    \"\"\"Extracted tables. Is an empty list if 'extract_tables' is not set to True in the ExtractionConfig.\"\"\"\n    chunks: list[str] = field(default_factory=list)\n    \"\"\"The extracted content chunks. This is an empty list if 'chunk_content' is not set to True in the ExtractionConfig.\"\"\"\n</code></pre>"},{"location":"api-reference/types/#kreuzberg.ExtractionResult-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#kreuzberg.ExtractionResult.chunks","title":"<code>chunks: list[str] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The extracted content chunks. This is an empty list if 'chunk_content' is not set to True in the ExtractionConfig.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionResult.content","title":"<code>content: str</code>  <code>instance-attribute</code>","text":"<p>The extracted content.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionResult.metadata","title":"<code>metadata: Metadata</code>  <code>instance-attribute</code>","text":"<p>The metadata of the content.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionResult.mime_type","title":"<code>mime_type: str</code>  <code>instance-attribute</code>","text":"<p>The mime type of the extracted content. Is either text/plain or text/markdown.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionResult.tables","title":"<code>tables: list[TableData] = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extracted tables. Is an empty list if 'extract_tables' is not set to True in the ExtractionConfig.</p>"},{"location":"api-reference/types/#extractionconfig","title":"ExtractionConfig","text":"<p>Configuration options for extraction functions:</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig","title":"<code>kreuzberg.ExtractionConfig</code>  <code>dataclass</code>","text":"<p>Represents configuration settings for an extraction process.</p> <p>This class encapsulates the configuration options for extracting text from images or documents using Optical Character Recognition (OCR). It provides options to customize the OCR behavior, select the backend engine, and configure engine-specific parameters.</p> Source code in <code>kreuzberg/_types.py</code> <pre><code>@dataclass(unsafe_hash=True)\nclass ExtractionConfig:\n    \"\"\"Represents configuration settings for an extraction process.\n\n    This class encapsulates the configuration options for extracting text\n    from images or documents using Optical Character Recognition (OCR). It\n    provides options to customize the OCR behavior, select the backend\n    engine, and configure engine-specific parameters.\n    \"\"\"\n\n    force_ocr: bool = False\n    \"\"\"Whether to force OCR.\"\"\"\n    chunk_content: bool = False\n    \"\"\"Whether to chunk the content into smaller chunks.\"\"\"\n    extract_tables: bool = False\n    \"\"\"Whether to extract tables from the content. This requires the 'gmft' dependency.\"\"\"\n    max_chars: int = DEFAULT_MAX_CHARACTERS\n    \"\"\"The size of each chunk in characters.\"\"\"\n    max_overlap: int = DEFAULT_MAX_OVERLAP\n    \"\"\"The overlap between chunks in characters.\"\"\"\n    ocr_backend: OcrBackendType | None = \"tesseract\"\n    \"\"\"The OCR backend to use.\n\n    Notes:\n        - If set to 'None', OCR will not be performed.\n    \"\"\"\n    ocr_config: TesseractConfig | PaddleOCRConfig | EasyOCRConfig | None = None\n    \"\"\"Configuration to pass to the OCR backend.\"\"\"\n    gmft_config: GMFTConfig | None = None\n    \"\"\"GMFT configuration.\"\"\"\n    post_processing_hooks: list[PostProcessingHook] | None = None\n    \"\"\"Post processing hooks to call after processing is done and before the final result is returned.\"\"\"\n    validators: list[ValidationHook] | None = None\n    \"\"\"Validation hooks to call after processing is done and before post-processing and result return.\"\"\"\n\n    def __post_init__(self) -&gt; None:\n        from kreuzberg._ocr._easyocr import EasyOCRConfig\n        from kreuzberg._ocr._paddleocr import PaddleOCRConfig\n        from kreuzberg._ocr._tesseract import TesseractConfig\n\n        if self.ocr_backend is None and self.ocr_config is not None:\n            raise ValidationError(\"'ocr_backend' is None but 'ocr_config' is provided\")\n\n        if self.ocr_config is not None and (\n            (self.ocr_backend == \"tesseract\" and not isinstance(self.ocr_config, TesseractConfig))\n            or (self.ocr_backend == \"easyocr\" and not isinstance(self.ocr_config, EasyOCRConfig))\n            or (self.ocr_backend == \"paddleocr\" and not isinstance(self.ocr_config, PaddleOCRConfig))\n        ):\n            raise ValidationError(\n                \"incompatible 'ocr_config' value provided for 'ocr_backend'\",\n                context={\"ocr_backend\": self.ocr_backend, \"ocr_config\": type(self.ocr_config).__name__},\n            )\n\n    def get_config_dict(self) -&gt; dict[str, Any]:\n        \"\"\"Returns the OCR configuration object based on the backend specified.\n\n        Returns:\n            A dict of the OCR configuration or an empty dict if no backend is provided.\n        \"\"\"\n        if self.ocr_backend is not None:\n            if self.ocr_config is not None:\n                return asdict(self.ocr_config)\n            if self.ocr_backend == \"tesseract\":\n                from kreuzberg._ocr._tesseract import TesseractConfig\n\n                return asdict(TesseractConfig())\n            if self.ocr_backend == \"easyocr\":\n                from kreuzberg._ocr._easyocr import EasyOCRConfig\n\n                return asdict(EasyOCRConfig())\n            from kreuzberg._ocr._paddleocr import PaddleOCRConfig\n\n            return asdict(PaddleOCRConfig())\n        return {}\n</code></pre>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.chunk_content","title":"<code>chunk_content: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to chunk the content into smaller chunks.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.extract_tables","title":"<code>extract_tables: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to extract tables from the content. This requires the 'gmft' dependency.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.force_ocr","title":"<code>force_ocr: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to force OCR.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.gmft_config","title":"<code>gmft_config: GMFTConfig | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>GMFT configuration.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.max_chars","title":"<code>max_chars: int = DEFAULT_MAX_CHARACTERS</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The size of each chunk in characters.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.max_overlap","title":"<code>max_overlap: int = DEFAULT_MAX_OVERLAP</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The overlap between chunks in characters.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.ocr_backend","title":"<code>ocr_backend: OcrBackendType | None = 'tesseract'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The OCR backend to use.</p> Notes <ul> <li>If set to 'None', OCR will not be performed.</li> </ul>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.ocr_config","title":"<code>ocr_config: TesseractConfig | PaddleOCRConfig | EasyOCRConfig | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Configuration to pass to the OCR backend.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.post_processing_hooks","title":"<code>post_processing_hooks: list[PostProcessingHook] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Post processing hooks to call after processing is done and before the final result is returned.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.validators","title":"<code>validators: list[ValidationHook] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Validation hooks to call after processing is done and before post-processing and result return.</p>"},{"location":"api-reference/types/#kreuzberg.ExtractionConfig-functions","title":"Functions","text":""},{"location":"api-reference/types/#kreuzberg.ExtractionConfig.get_config_dict","title":"<code>get_config_dict() -&gt; dict[str, Any]</code>","text":"<p>Returns the OCR configuration object based on the backend specified.</p> RETURNS DESCRIPTION <code>dict[str, Any]</code> <p>A dict of the OCR configuration or an empty dict if no backend is provided.</p> Source code in <code>kreuzberg/_types.py</code> <pre><code>def get_config_dict(self) -&gt; dict[str, Any]:\n    \"\"\"Returns the OCR configuration object based on the backend specified.\n\n    Returns:\n        A dict of the OCR configuration or an empty dict if no backend is provided.\n    \"\"\"\n    if self.ocr_backend is not None:\n        if self.ocr_config is not None:\n            return asdict(self.ocr_config)\n        if self.ocr_backend == \"tesseract\":\n            from kreuzberg._ocr._tesseract import TesseractConfig\n\n            return asdict(TesseractConfig())\n        if self.ocr_backend == \"easyocr\":\n            from kreuzberg._ocr._easyocr import EasyOCRConfig\n\n            return asdict(EasyOCRConfig())\n        from kreuzberg._ocr._paddleocr import PaddleOCRConfig\n\n        return asdict(PaddleOCRConfig())\n    return {}\n</code></pre>"},{"location":"api-reference/types/#tabledata","title":"TableData","text":"<p>A TypedDict that contains data extracted from tables in documents:</p>"},{"location":"api-reference/types/#kreuzberg.TableData","title":"<code>kreuzberg.TableData</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Table data, returned from table extraction.</p> Source code in <code>kreuzberg/_types.py</code> <pre><code>class TableData(TypedDict):\n    \"\"\"Table data, returned from table extraction.\"\"\"\n\n    cropped_image: Image\n    \"\"\"The cropped image of the table.\"\"\"\n    df: DataFrame\n    \"\"\"The table data as a pandas DataFrame.\"\"\"\n    page_number: int\n    \"\"\"The page number of the table.\"\"\"\n    text: str\n    \"\"\"The table text as a markdown string.\"\"\"\n</code></pre>"},{"location":"api-reference/types/#kreuzberg.TableData-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#kreuzberg.TableData.cropped_image","title":"<code>cropped_image: Image</code>  <code>instance-attribute</code>","text":"<p>The cropped image of the table.</p>"},{"location":"api-reference/types/#kreuzberg.TableData.df","title":"<code>df: DataFrame</code>  <code>instance-attribute</code>","text":"<p>The table data as a pandas DataFrame.</p>"},{"location":"api-reference/types/#kreuzberg.TableData.page_number","title":"<code>page_number: int</code>  <code>instance-attribute</code>","text":"<p>The page number of the table.</p>"},{"location":"api-reference/types/#kreuzberg.TableData.text","title":"<code>text: str</code>  <code>instance-attribute</code>","text":"<p>The table text as a markdown string.</p>"},{"location":"api-reference/types/#ocr-configuration","title":"OCR Configuration","text":""},{"location":"api-reference/types/#tesseractconfig","title":"TesseractConfig","text":""},{"location":"api-reference/types/#kreuzberg.TesseractConfig","title":"<code>kreuzberg.TesseractConfig</code>  <code>dataclass</code>","text":"<p>Configuration options for Tesseract OCR engine.</p> Source code in <code>kreuzberg/_ocr/_tesseract.py</code> <pre><code>@dataclass(unsafe_hash=True, frozen=True)\nclass TesseractConfig:\n    \"\"\"Configuration options for Tesseract OCR engine.\"\"\"\n\n    classify_use_pre_adapted_templates: bool = True\n    \"\"\"Whether to use pre-adapted templates during classification to improve recognition accuracy.\"\"\"\n    language: str = \"eng\"\n    \"\"\"Language code to use for OCR.\n    Examples:\n            -   'eng' for English\n            -   'deu' for German\n            -    multiple languages combined with '+', e.g. 'eng+deu')\n    \"\"\"\n    language_model_ngram_on: bool = True\n    \"\"\"Enable or disable the use of n-gram-based language models for improved text recognition.\"\"\"\n    psm: PSMMode = PSMMode.AUTO\n    \"\"\"Page segmentation mode (PSM) to guide Tesseract on how to segment the image (e.g., single block, single line).\"\"\"\n    tessedit_dont_blkrej_good_wds: bool = True\n    \"\"\"If True, prevents block rejection of words identified as good, improving text output quality.\"\"\"\n    tessedit_dont_rowrej_good_wds: bool = True\n    \"\"\"If True, prevents row rejection of words identified as good, avoiding unnecessary omissions.\"\"\"\n    tessedit_enable_dict_correction: bool = True\n    \"\"\"Enable or disable dictionary-based correction for recognized text to improve word accuracy.\"\"\"\n    tessedit_use_primary_params_model: bool = True\n    \"\"\"If True, forces the use of the primary parameters model for text recognition.\"\"\"\n    textord_space_size_is_variable: bool = True\n    \"\"\"Allow variable spacing between words, useful for text with irregular spacing.\"\"\"\n    thresholding_method: bool = False\n    \"\"\"Enable or disable specific thresholding methods during image preprocessing for better OCR accuracy.\"\"\"\n</code></pre>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#kreuzberg.TesseractConfig.classify_use_pre_adapted_templates","title":"<code>classify_use_pre_adapted_templates: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use pre-adapted templates during classification to improve recognition accuracy.</p>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig.language","title":"<code>language: str = 'eng'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Language code to use for OCR. Examples:         -   'eng' for English         -   'deu' for German         -    multiple languages combined with '+', e.g. 'eng+deu')</p>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig.language_model_ngram_on","title":"<code>language_model_ngram_on: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable or disable the use of n-gram-based language models for improved text recognition.</p>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig.psm","title":"<code>psm: PSMMode = PSMMode.AUTO</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Page segmentation mode (PSM) to guide Tesseract on how to segment the image (e.g., single block, single line).</p>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig.tessedit_dont_blkrej_good_wds","title":"<code>tessedit_dont_blkrej_good_wds: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, prevents block rejection of words identified as good, improving text output quality.</p>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig.tessedit_dont_rowrej_good_wds","title":"<code>tessedit_dont_rowrej_good_wds: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, prevents row rejection of words identified as good, avoiding unnecessary omissions.</p>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig.tessedit_enable_dict_correction","title":"<code>tessedit_enable_dict_correction: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable or disable dictionary-based correction for recognized text to improve word accuracy.</p>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig.tessedit_use_primary_params_model","title":"<code>tessedit_use_primary_params_model: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If True, forces the use of the primary parameters model for text recognition.</p>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig.textord_space_size_is_variable","title":"<code>textord_space_size_is_variable: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Allow variable spacing between words, useful for text with irregular spacing.</p>"},{"location":"api-reference/types/#kreuzberg.TesseractConfig.thresholding_method","title":"<code>thresholding_method: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable or disable specific thresholding methods during image preprocessing for better OCR accuracy.</p>"},{"location":"api-reference/types/#easyocrconfig","title":"EasyOCRConfig","text":""},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig","title":"<code>kreuzberg.EasyOCRConfig</code>  <code>dataclass</code>","text":"<p>Configuration options for EasyOCR.</p> Source code in <code>kreuzberg/_ocr/_easyocr.py</code> <pre><code>@dataclass(unsafe_hash=True, frozen=True)\nclass EasyOCRConfig:\n    \"\"\"Configuration options for EasyOCR.\"\"\"\n\n    add_margin: float = 0.1\n    \"\"\"Extend bounding boxes in all directions.\"\"\"\n    adjust_contrast: float = 0.5\n    \"\"\"Target contrast level for low contrast text.\"\"\"\n    beam_width: int = 5\n    \"\"\"Beam width for beam search in recognition.\"\"\"\n    canvas_size: int = 2560\n    \"\"\"Maximum image dimension for detection.\"\"\"\n    contrast_ths: float = 0.1\n    \"\"\"Contrast threshold for preprocessing.\"\"\"\n    decoder: Literal[\"greedy\", \"beamsearch\", \"wordbeamsearch\"] = \"greedy\"\n    \"\"\"Decoder method. Options: 'greedy', 'beamsearch', 'wordbeamsearch'.\"\"\"\n    height_ths: float = 0.5\n    \"\"\"Maximum difference in box height for merging.\"\"\"\n    language: str | list[str] = \"en\"\n    \"\"\"Language or languages to use for OCR.\"\"\"\n    link_threshold: float = 0.4\n    \"\"\"Link confidence threshold.\"\"\"\n    low_text: float = 0.4\n    \"\"\"Text low-bound score.\"\"\"\n    mag_ratio: float = 1.0\n    \"\"\"Image magnification ratio.\"\"\"\n    min_size: int = 10\n    \"\"\"Minimum text box size in pixels.\"\"\"\n    rotation_info: list[int] | None = None\n    \"\"\"List of angles to try for detection.\"\"\"\n    slope_ths: float = 0.1\n    \"\"\"Maximum slope for merging text boxes.\"\"\"\n    text_threshold: float = 0.7\n    \"\"\"Text confidence threshold.\"\"\"\n    use_gpu: bool = False\n    \"\"\"Whether to use GPU for inference.\"\"\"\n    width_ths: float = 0.5\n    \"\"\"Maximum horizontal distance for merging boxes.\"\"\"\n    x_ths: float = 1.0\n    \"\"\"Maximum horizontal distance for paragraph merging.\"\"\"\n    y_ths: float = 0.5\n    \"\"\"Maximum vertical distance for paragraph merging.\"\"\"\n    ycenter_ths: float = 0.5\n    \"\"\"Maximum shift in y direction for merging.\"\"\"\n</code></pre>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.add_margin","title":"<code>add_margin: float = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Extend bounding boxes in all directions.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.adjust_contrast","title":"<code>adjust_contrast: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Target contrast level for low contrast text.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.beam_width","title":"<code>beam_width: int = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Beam width for beam search in recognition.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.canvas_size","title":"<code>canvas_size: int = 2560</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum image dimension for detection.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.contrast_ths","title":"<code>contrast_ths: float = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Contrast threshold for preprocessing.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.decoder","title":"<code>decoder: Literal['greedy', 'beamsearch', 'wordbeamsearch'] = 'greedy'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Decoder method. Options: 'greedy', 'beamsearch', 'wordbeamsearch'.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.height_ths","title":"<code>height_ths: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum difference in box height for merging.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.language","title":"<code>language: str | list[str] = 'en'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Language or languages to use for OCR.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.link_threshold","title":"<code>link_threshold: float = 0.4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Link confidence threshold.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.low_text","title":"<code>low_text: float = 0.4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Text low-bound score.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.mag_ratio","title":"<code>mag_ratio: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Image magnification ratio.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.min_size","title":"<code>min_size: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Minimum text box size in pixels.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.rotation_info","title":"<code>rotation_info: list[int] | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>List of angles to try for detection.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.slope_ths","title":"<code>slope_ths: float = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum slope for merging text boxes.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.text_threshold","title":"<code>text_threshold: float = 0.7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Text confidence threshold.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.use_gpu","title":"<code>use_gpu: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use GPU for inference.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.width_ths","title":"<code>width_ths: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum horizontal distance for merging boxes.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.x_ths","title":"<code>x_ths: float = 1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum horizontal distance for paragraph merging.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.y_ths","title":"<code>y_ths: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum vertical distance for paragraph merging.</p>"},{"location":"api-reference/types/#kreuzberg.EasyOCRConfig.ycenter_ths","title":"<code>ycenter_ths: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum shift in y direction for merging.</p>"},{"location":"api-reference/types/#paddleocrconfig","title":"PaddleOCRConfig","text":""},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig","title":"<code>kreuzberg.PaddleOCRConfig</code>  <code>dataclass</code>","text":"<p>Configuration options for PaddleOCR.</p> <p>This TypedDict provides type hints and documentation for all PaddleOCR parameters.</p> Source code in <code>kreuzberg/_ocr/_paddleocr.py</code> <pre><code>@dataclass(unsafe_hash=True, frozen=True)\nclass PaddleOCRConfig:\n    \"\"\"Configuration options for PaddleOCR.\n\n    This TypedDict provides type hints and documentation for all PaddleOCR parameters.\n    \"\"\"\n\n    cls_image_shape: str = \"3,48,192\"\n    \"\"\"Image shape for classification algorithm in format 'channels,height,width'.\"\"\"\n    det_algorithm: Literal[\"DB\", \"EAST\", \"SAST\", \"PSE\", \"FCE\", \"PAN\", \"CT\", \"DB++\", \"Layout\"] = \"DB\"\n    \"\"\"Detection algorithm.\"\"\"\n    det_db_box_thresh: float = 0.5\n    \"\"\"Score threshold for detected boxes. Boxes below this value are discarded.\"\"\"\n    det_db_thresh: float = 0.3\n    \"\"\"Binarization threshold for DB output map.\"\"\"\n    det_db_unclip_ratio: float = 2.0\n    \"\"\"Expansion ratio for detected text boxes.\"\"\"\n    det_east_cover_thresh: float = 0.1\n    \"\"\"Score threshold for EAST output boxes.\"\"\"\n    det_east_nms_thresh: float = 0.2\n    \"\"\"NMS threshold for EAST model output boxes.\"\"\"\n    det_east_score_thresh: float = 0.8\n    \"\"\"Binarization threshold for EAST output map.\"\"\"\n    det_max_side_len: int = 960\n    \"\"\"Maximum size of image long side. Images exceeding this will be proportionally resized.\"\"\"\n    drop_score: float = 0.5\n    \"\"\"Filter recognition results by confidence score. Results below this are discarded.\"\"\"\n    enable_mkldnn: bool = False\n    \"\"\"Whether to enable MKL-DNN acceleration (Intel CPU only).\"\"\"\n    gpu_mem: int = 8000\n    \"\"\"GPU memory size (in MB) to use for initialization.\"\"\"\n    language: str = \"en\"\n    \"\"\"Language to use for OCR.\"\"\"\n    max_text_length: int = 25\n    \"\"\"Maximum text length that the recognition algorithm can recognize.\"\"\"\n    rec: bool = True\n    \"\"\"Enable text recognition when using the ocr() function.\"\"\"\n    rec_algorithm: Literal[\n        \"CRNN\",\n        \"SRN\",\n        \"NRTR\",\n        \"SAR\",\n        \"SEED\",\n        \"SVTR\",\n        \"SVTR_LCNet\",\n        \"ViTSTR\",\n        \"ABINet\",\n        \"VisionLAN\",\n        \"SPIN\",\n        \"RobustScanner\",\n        \"RFL\",\n    ] = \"CRNN\"\n    \"\"\"Recognition algorithm.\"\"\"\n    rec_image_shape: str = \"3,32,320\"\n    \"\"\"Image shape for recognition algorithm in format 'channels,height,width'.\"\"\"\n    table: bool = True\n    \"\"\"Whether to enable table recognition.\"\"\"\n    use_angle_cls: bool = True\n    \"\"\"Whether to use text orientation classification model.\"\"\"\n    use_gpu: bool = False\n    \"\"\"Whether to use GPU for inference. Requires installing the paddlepaddle-gpu package\"\"\"\n    use_space_char: bool = True\n    \"\"\"Whether to recognize spaces.\"\"\"\n    use_zero_copy_run: bool = False\n    \"\"\"Whether to enable zero_copy_run for inference optimization.\"\"\"\n</code></pre>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.cls_image_shape","title":"<code>cls_image_shape: str = '3,48,192'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Image shape for classification algorithm in format 'channels,height,width'.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.det_algorithm","title":"<code>det_algorithm: Literal['DB', 'EAST', 'SAST', 'PSE', 'FCE', 'PAN', 'CT', 'DB++', 'Layout'] = 'DB'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Detection algorithm.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.det_db_box_thresh","title":"<code>det_db_box_thresh: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Score threshold for detected boxes. Boxes below this value are discarded.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.det_db_thresh","title":"<code>det_db_thresh: float = 0.3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Binarization threshold for DB output map.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.det_db_unclip_ratio","title":"<code>det_db_unclip_ratio: float = 2.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Expansion ratio for detected text boxes.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.det_east_cover_thresh","title":"<code>det_east_cover_thresh: float = 0.1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Score threshold for EAST output boxes.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.det_east_nms_thresh","title":"<code>det_east_nms_thresh: float = 0.2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>NMS threshold for EAST model output boxes.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.det_east_score_thresh","title":"<code>det_east_score_thresh: float = 0.8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Binarization threshold for EAST output map.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.det_max_side_len","title":"<code>det_max_side_len: int = 960</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum size of image long side. Images exceeding this will be proportionally resized.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.drop_score","title":"<code>drop_score: float = 0.5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Filter recognition results by confidence score. Results below this are discarded.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.enable_mkldnn","title":"<code>enable_mkldnn: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to enable MKL-DNN acceleration (Intel CPU only).</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.gpu_mem","title":"<code>gpu_mem: int = 8000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>GPU memory size (in MB) to use for initialization.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.language","title":"<code>language: str = 'en'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Language to use for OCR.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.max_text_length","title":"<code>max_text_length: int = 25</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum text length that the recognition algorithm can recognize.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.rec","title":"<code>rec: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable text recognition when using the ocr() function.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.rec_algorithm","title":"<code>rec_algorithm: Literal['CRNN', 'SRN', 'NRTR', 'SAR', 'SEED', 'SVTR', 'SVTR_LCNet', 'ViTSTR', 'ABINet', 'VisionLAN', 'SPIN', 'RobustScanner', 'RFL'] = 'CRNN'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Recognition algorithm.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.rec_image_shape","title":"<code>rec_image_shape: str = '3,32,320'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Image shape for recognition algorithm in format 'channels,height,width'.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.table","title":"<code>table: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to enable table recognition.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.use_angle_cls","title":"<code>use_angle_cls: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use text orientation classification model.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.use_gpu","title":"<code>use_gpu: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to use GPU for inference. Requires installing the paddlepaddle-gpu package</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.use_space_char","title":"<code>use_space_char: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to recognize spaces.</p>"},{"location":"api-reference/types/#kreuzberg.PaddleOCRConfig.use_zero_copy_run","title":"<code>use_zero_copy_run: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Whether to enable zero_copy_run for inference optimization.</p>"},{"location":"api-reference/types/#gmft-configuration","title":"GMFT Configuration","text":"<p>Configuration options for the GMFT table extraction engine:</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig","title":"<code>kreuzberg.GMFTConfig</code>  <code>dataclass</code>","text":"<p>Configuration options for GMFT.</p> <p>This class encapsulates the configuration options for GMFT, providing a way to customize its behavior.</p> Source code in <code>kreuzberg/_gmft.py</code> <pre><code>@dataclass(unsafe_hash=True)\nclass GMFTConfig:\n    \"\"\"Configuration options for GMFT.\n\n    This class encapsulates the configuration options for GMFT, providing a way to customize its behavior.\n    \"\"\"\n\n    verbosity: int = 0\n    \"\"\"\n    Verbosity level for logging.\n\n    0: errors only\n    1: print warnings\n    2: print warnings and info\n    3: print warnings, info, and debug\n    \"\"\"\n    formatter_base_threshold: float = 0.3\n    \"\"\"\n    Base threshold for the confidence demanded of a table feature (row/column).\n\n    Note that a low threshold is actually better, because overzealous rows means that generally, numbers are still aligned and there are just many empty rows (having fewer rows than expected merges cells, which is bad).\n    \"\"\"\n    cell_required_confidence: dict[Literal[0, 1, 2, 3, 4, 5, 6], float] = field(\n        default_factory=lambda: {\n            0: 0.3,\n            1: 0.3,\n            2: 0.3,\n            3: 0.3,\n            4: 0.5,\n            5: 0.5,\n            6: 99,\n        },\n        hash=False,\n    )\n    \"\"\"\n    Confidences required (&gt;=) for a row/column feature to be considered good. See TATRFormattedTable.id2label\n\n    But low confidences may be better than too high confidence (see formatter_base_threshold)\n    \"\"\"\n    detector_base_threshold: float = 0.9\n    \"\"\"Minimum confidence score required for a table\"\"\"\n    remove_null_rows: bool = True\n    \"\"\"\n    Flag to remove rows with no text.\n    \"\"\"\n    enable_multi_header: bool = False\n    \"\"\"\n    Enable multi-indices in the dataframe.\n\n    If false, then multiple headers will be merged column-wise.\n    \"\"\"\n    semantic_spanning_cells: bool = False\n    \"\"\"\n    [Experimental] Enable semantic spanning cells, which often encode hierarchical multi-level indices.\n    \"\"\"\n    semantic_hierarchical_left_fill: str | None = \"algorithm\"\n    \"\"\"\n    [Experimental] When semantic spanning cells is enabled, when a left header is detected which might represent a group of rows, that same value is reduplicated for each row.\n\n    Possible values: 'algorithm', 'deep', None.\n\n    'algorithm': assumes that the higher-level header is always the first row followed by several empty rows.\n    'deep': merges headers according to the spanning cells detected by the Table Transformer.\n    None: headers are not duplicated.\n    \"\"\"\n    large_table_if_n_rows_removed: int = 8\n    \"\"\"\n    If &gt;= n rows are removed due to non-maxima suppression (NMS), then this table is classified as a large table.\n    \"\"\"\n    large_table_threshold: int = 10\n    \"\"\"\n    With large tables, table transformer struggles with placing too many overlapping rows. Luckily, with more rows, we have more info on the usual size of text, which we can use to make a guess on the height such that no rows are merged or overlapping.\n\n    Large table assumption is only applied when (# of rows &gt; large_table_threshold) AND (total overlap &gt; large_table_row_overlap_threshold). Set 9999 to disable; set 0 to force large table assumption to run every time.\n    \"\"\"\n    large_table_row_overlap_threshold: float = 0.2\n    \"\"\"\n    With large tables, table transformer struggles with placing too many overlapping rows. Luckily, with more rows, we have more info on the usual size of text, which we can use to make a guess on the height such that no rows are merged or overlapping.\n\n    Large table assumption is only applied when (# of rows &gt; large_table_threshold) AND (total overlap &gt; large_table_row_overlap_threshold).\n    \"\"\"\n    large_table_maximum_rows: int = 1000\n    \"\"\"\n    Maximum number of rows allowed for a large table.\n    \"\"\"\n    force_large_table_assumption: bool | None = None\n    \"\"\"\n    Force the large table assumption to be applied, regardless of the number of rows and overlap.\n    \"\"\"\n</code></pre>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#kreuzberg.GMFTConfig.cell_required_confidence","title":"<code>cell_required_confidence: dict[Literal[0, 1, 2, 3, 4, 5, 6], float] = field(default_factory=lambda: {0: 0.3, 1: 0.3, 2: 0.3, 3: 0.3, 4: 0.5, 5: 0.5, 6: 99}, hash=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Confidences required (&gt;=) for a row/column feature to be considered good. See TATRFormattedTable.id2label</p> <p>But low confidences may be better than too high confidence (see formatter_base_threshold)</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.detector_base_threshold","title":"<code>detector_base_threshold: float = 0.9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Minimum confidence score required for a table</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.enable_multi_header","title":"<code>enable_multi_header: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Enable multi-indices in the dataframe.</p> <p>If false, then multiple headers will be merged column-wise.</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.force_large_table_assumption","title":"<code>force_large_table_assumption: bool | None = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Force the large table assumption to be applied, regardless of the number of rows and overlap.</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.formatter_base_threshold","title":"<code>formatter_base_threshold: float = 0.3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Base threshold for the confidence demanded of a table feature (row/column).</p> <p>Note that a low threshold is actually better, because overzealous rows means that generally, numbers are still aligned and there are just many empty rows (having fewer rows than expected merges cells, which is bad).</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.large_table_if_n_rows_removed","title":"<code>large_table_if_n_rows_removed: int = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>If &gt;= n rows are removed due to non-maxima suppression (NMS), then this table is classified as a large table.</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.large_table_maximum_rows","title":"<code>large_table_maximum_rows: int = 1000</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Maximum number of rows allowed for a large table.</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.large_table_row_overlap_threshold","title":"<code>large_table_row_overlap_threshold: float = 0.2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>With large tables, table transformer struggles with placing too many overlapping rows. Luckily, with more rows, we have more info on the usual size of text, which we can use to make a guess on the height such that no rows are merged or overlapping.</p> <p>Large table assumption is only applied when (# of rows &gt; large_table_threshold) AND (total overlap &gt; large_table_row_overlap_threshold).</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.large_table_threshold","title":"<code>large_table_threshold: int = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>With large tables, table transformer struggles with placing too many overlapping rows. Luckily, with more rows, we have more info on the usual size of text, which we can use to make a guess on the height such that no rows are merged or overlapping.</p> <p>Large table assumption is only applied when (# of rows &gt; large_table_threshold) AND (total overlap &gt; large_table_row_overlap_threshold). Set 9999 to disable; set 0 to force large table assumption to run every time.</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.remove_null_rows","title":"<code>remove_null_rows: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Flag to remove rows with no text.</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.semantic_hierarchical_left_fill","title":"<code>semantic_hierarchical_left_fill: str | None = 'algorithm'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Experimental] When semantic spanning cells is enabled, when a left header is detected which might represent a group of rows, that same value is reduplicated for each row.</p> <p>Possible values: 'algorithm', 'deep', None.</p> <p>'algorithm': assumes that the higher-level header is always the first row followed by several empty rows. 'deep': merges headers according to the spanning cells detected by the Table Transformer. None: headers are not duplicated.</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.semantic_spanning_cells","title":"<code>semantic_spanning_cells: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>[Experimental] Enable semantic spanning cells, which often encode hierarchical multi-level indices.</p>"},{"location":"api-reference/types/#kreuzberg.GMFTConfig.verbosity","title":"<code>verbosity: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Verbosity level for logging.</p> <p>0: errors only 1: print warnings 2: print warnings and info 3: print warnings, info, and debug</p>"},{"location":"api-reference/types/#psmmode-page-segmentation-mode","title":"PSMMode (Page Segmentation Mode)","text":""},{"location":"api-reference/types/#kreuzberg.PSMMode","title":"<code>kreuzberg.PSMMode</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Enum for Tesseract Page Segmentation Modes (PSM) with human-readable values.</p> Source code in <code>kreuzberg/_ocr/_tesseract.py</code> <pre><code>class PSMMode(Enum):\n    \"\"\"Enum for Tesseract Page Segmentation Modes (PSM) with human-readable values.\"\"\"\n\n    OSD_ONLY = 0\n    \"\"\"Orientation and script detection only.\"\"\"\n    AUTO_OSD = 1\n    \"\"\"Automatic page segmentation with orientation and script detection.\"\"\"\n    AUTO_ONLY = 2\n    \"\"\"Automatic page segmentation without OSD.\"\"\"\n    AUTO = 3\n    \"\"\"Fully automatic page segmentation (default).\"\"\"\n    SINGLE_COLUMN = 4\n    \"\"\"Assume a single column of text.\"\"\"\n    SINGLE_BLOCK_VERTICAL = 5\n    \"\"\"Assume a single uniform block of vertically aligned text.\"\"\"\n    SINGLE_BLOCK = 6\n    \"\"\"Assume a single uniform block of text.\"\"\"\n    SINGLE_LINE = 7\n    \"\"\"Treat the image as a single text line.\"\"\"\n    SINGLE_WORD = 8\n    \"\"\"Treat the image as a single word.\"\"\"\n    CIRCLE_WORD = 9\n    \"\"\"Treat the image as a single word in a circle.\"\"\"\n    SINGLE_CHAR = 10\n    \"\"\"Treat the image as a single character.\"\"\"\n</code></pre>"},{"location":"api-reference/types/#kreuzberg.PSMMode-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#kreuzberg.PSMMode.AUTO","title":"<code>AUTO = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Fully automatic page segmentation (default).</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.AUTO_ONLY","title":"<code>AUTO_ONLY = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Automatic page segmentation without OSD.</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.AUTO_OSD","title":"<code>AUTO_OSD = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Automatic page segmentation with orientation and script detection.</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.CIRCLE_WORD","title":"<code>CIRCLE_WORD = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Treat the image as a single word in a circle.</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.OSD_ONLY","title":"<code>OSD_ONLY = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Orientation and script detection only.</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.SINGLE_BLOCK","title":"<code>SINGLE_BLOCK = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Assume a single uniform block of text.</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.SINGLE_BLOCK_VERTICAL","title":"<code>SINGLE_BLOCK_VERTICAL = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Assume a single uniform block of vertically aligned text.</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.SINGLE_CHAR","title":"<code>SINGLE_CHAR = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Treat the image as a single character.</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.SINGLE_COLUMN","title":"<code>SINGLE_COLUMN = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Assume a single column of text.</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.SINGLE_LINE","title":"<code>SINGLE_LINE = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Treat the image as a single text line.</p>"},{"location":"api-reference/types/#kreuzberg.PSMMode.SINGLE_WORD","title":"<code>SINGLE_WORD = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Treat the image as a single word.</p>"},{"location":"api-reference/types/#metadata","title":"Metadata","text":"<p>A TypedDict that contains optional metadata fields extracted from documents:</p>"},{"location":"api-reference/types/#kreuzberg.Metadata","title":"<code>kreuzberg.Metadata</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Base metadata common to all document types.</p> <p>All fields will only be included if they contain non-empty values. Any field that would be empty or None is omitted from the dictionary.</p> Source code in <code>kreuzberg/_types.py</code> <pre><code>class Metadata(TypedDict, total=False):\n    \"\"\"Base metadata common to all document types.\n\n    All fields will only be included if they contain non-empty values.\n    Any field that would be empty or None is omitted from the dictionary.\n    \"\"\"\n\n    authors: NotRequired[list[str]]\n    \"\"\"List of document authors.\"\"\"\n    categories: NotRequired[list[str]]\n    \"\"\"Categories or classifications.\"\"\"\n    citations: NotRequired[list[str]]\n    \"\"\"Citation identifiers.\"\"\"\n    comments: NotRequired[str]\n    \"\"\"General comments.\"\"\"\n    copyright: NotRequired[str]\n    \"\"\"Copyright information.\"\"\"\n    created_at: NotRequired[str]\n    \"\"\"Creation timestamp in ISO format.\"\"\"\n    created_by: NotRequired[str]\n    \"\"\"Document creator.\"\"\"\n    description: NotRequired[str]\n    \"\"\"Document description.\"\"\"\n    fonts: NotRequired[list[str]]\n    \"\"\"List of fonts used in the document.\"\"\"\n    height: NotRequired[int]\n    \"\"\"Height of the document page/slide/image, if applicable.\"\"\"\n    identifier: NotRequired[str]\n    \"\"\"Unique document identifier.\"\"\"\n    keywords: NotRequired[list[str]]\n    \"\"\"Keywords or tags.\"\"\"\n    languages: NotRequired[list[str]]\n    \"\"\"Document language code.\"\"\"\n    license: NotRequired[str]\n    \"\"\"License information.\"\"\"\n    modified_at: NotRequired[str]\n    \"\"\"Last modification timestamp in ISO format.\"\"\"\n    modified_by: NotRequired[str]\n    \"\"\"Username of last modifier.\"\"\"\n    organization: NotRequired[str | list[str]]\n    \"\"\"Organizational affiliation.\"\"\"\n    publisher: NotRequired[str]\n    \"\"\"Publisher or organization name.\"\"\"\n    references: NotRequired[list[str]]\n    \"\"\"Reference entries.\"\"\"\n    status: NotRequired[str]\n    \"\"\"Document status (e.g., draft, final).\"\"\"\n    subject: NotRequired[str]\n    \"\"\"Document subject or topic.\"\"\"\n    subtitle: NotRequired[str]\n    \"\"\"Document subtitle.\"\"\"\n    summary: NotRequired[str]\n    \"\"\"Document Summary\"\"\"\n    title: NotRequired[str]\n    \"\"\"Document title.\"\"\"\n    version: NotRequired[str]\n    \"\"\"Version identifier or revision number.\"\"\"\n    width: NotRequired[int]\n    \"\"\"Width of the document page/slide/image, if applicable.\"\"\"\n</code></pre>"},{"location":"api-reference/types/#kreuzberg.Metadata-attributes","title":"Attributes","text":""},{"location":"api-reference/types/#kreuzberg.Metadata.authors","title":"<code>authors: NotRequired[list[str]]</code>  <code>instance-attribute</code>","text":"<p>List of document authors.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.categories","title":"<code>categories: NotRequired[list[str]]</code>  <code>instance-attribute</code>","text":"<p>Categories or classifications.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.citations","title":"<code>citations: NotRequired[list[str]]</code>  <code>instance-attribute</code>","text":"<p>Citation identifiers.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.comments","title":"<code>comments: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>General comments.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.copyright","title":"<code>copyright: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Copyright information.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.created_at","title":"<code>created_at: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Creation timestamp in ISO format.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.created_by","title":"<code>created_by: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Document creator.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.description","title":"<code>description: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Document description.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.fonts","title":"<code>fonts: NotRequired[list[str]]</code>  <code>instance-attribute</code>","text":"<p>List of fonts used in the document.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.height","title":"<code>height: NotRequired[int]</code>  <code>instance-attribute</code>","text":"<p>Height of the document page/slide/image, if applicable.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.identifier","title":"<code>identifier: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Unique document identifier.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.keywords","title":"<code>keywords: NotRequired[list[str]]</code>  <code>instance-attribute</code>","text":"<p>Keywords or tags.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.languages","title":"<code>languages: NotRequired[list[str]]</code>  <code>instance-attribute</code>","text":"<p>Document language code.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.license","title":"<code>license: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>License information.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.modified_at","title":"<code>modified_at: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Last modification timestamp in ISO format.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.modified_by","title":"<code>modified_by: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Username of last modifier.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.organization","title":"<code>organization: NotRequired[str | list[str]]</code>  <code>instance-attribute</code>","text":"<p>Organizational affiliation.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.publisher","title":"<code>publisher: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Publisher or organization name.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.references","title":"<code>references: NotRequired[list[str]]</code>  <code>instance-attribute</code>","text":"<p>Reference entries.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.status","title":"<code>status: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Document status (e.g., draft, final).</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.subject","title":"<code>subject: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Document subject or topic.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.subtitle","title":"<code>subtitle: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Document subtitle.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.summary","title":"<code>summary: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Document Summary</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.title","title":"<code>title: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Document title.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.version","title":"<code>version: NotRequired[str]</code>  <code>instance-attribute</code>","text":"<p>Version identifier or revision number.</p>"},{"location":"api-reference/types/#kreuzberg.Metadata.width","title":"<code>width: NotRequired[int]</code>  <code>instance-attribute</code>","text":"<p>Width of the document page/slide/image, if applicable.</p>"},{"location":"examples/","title":"Kreuzberg Examples","text":"<p>This section provides practical examples of using Kreuzberg in various scenarios. These examples show real-world use cases and can serve as a starting point for your own implementations.</p>"},{"location":"examples/#available-examples","title":"Available Examples","text":"<ul> <li>Extraction Examples - Various text extraction patterns and configurations</li> </ul>"},{"location":"examples/#code-samples","title":"Code Samples","text":""},{"location":"examples/#basic-text-extraction","title":"Basic Text Extraction","text":"<pre><code>import asyncio\nfrom kreuzberg import extract_file\n\nasync def main():\n    result = await extract_file(\"document.pdf\")\n    print(f\"Text content: {result.content[:200]}...\")  # First 200 chars\n    print(f\"Document type: {result.mime_type}\")\n\n    if \"title\" in result.metadata:\n        print(f\"Title: {result.metadata['title']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/#multi-language-ocr","title":"Multi-language OCR","text":"<pre><code>from kreuzberg import extract_file, ExtractionConfig, TesseractConfig\n\nasync def extract_multilingual():\n    # Configure for English and German text\n    config = ExtractionConfig(ocr_config=TesseractConfig(language=\"eng+deu\"))\n\n    result = await extract_file(\"multilingual.pdf\", config=config)\n    return result.content\n\n# For Chinese text using PaddleOCR\nfrom kreuzberg import PaddleOCRConfig\n\nasync def extract_chinese():\n    config = ExtractionConfig(ocr_backend=\"paddleocr\", ocr_config=PaddleOCRConfig(language=\"ch\"))\n\n    result = await extract_file(\"chinese_document.jpg\", config=config)\n    return result.content\n</code></pre>"},{"location":"examples/extraction-examples/","title":"Extraction Examples","text":"<p>This page provides practical examples of using Kreuzberg for text extraction in various scenarios.</p>"},{"location":"examples/extraction-examples/#basic-extraction","title":"Basic Extraction","text":"<pre><code>import asyncio\nfrom kreuzberg import extract_file\n\nasync def main():\n    # Extract text from a PDF file\n    result = await extract_file(\"document.pdf\")\n    print(result.content)\n\n    # Access metadata\n    if result.metadata.get(\"title\"):\n        print(f\"Document title: {result.metadata['title']}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"examples/extraction-examples/#ocr-configuration","title":"OCR Configuration","text":"<p>Kreuzberg provides options to configure OCR for different languages and document layouts:</p> <pre><code>from kreuzberg import extract_file, TesseractConfig, PSMMode, ExtractionConfig\n\nasync def extract_with_ocr():\n    # Extract from a German document\n    result = await extract_file(\n        \"german_document.pdf\",\n        config=ExtractionConfig(\n            force_ocr=True,\n            ocr_config=TesseractConfig(\n                language=\"deu\", psm=PSMMode.SINGLE_BLOCK  # German language  # Treat as a single text block\n            ),\n        ),\n    )\n    print(result.content)\n\n    # Extract from a multilingual document\n    result = await extract_file(\n        \"multilingual.pdf\",\n        config=ExtractionConfig(\n            force_ocr=True,\n            ocr_config=TesseractConfig(\n                language=\"eng+deu\", psm=PSMMode.AUTO  # English primary, German secondary  # Automatic page segmentation\n            ),\n        ),\n    )\n    print(result.content)\n</code></pre>"},{"location":"examples/extraction-examples/#alternative-ocr-backends","title":"Alternative OCR Backends","text":"<p>Kreuzberg supports multiple OCR backends:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, EasyOCRConfig, PaddleOCRConfig\n\nasync def extract_with_different_backends():\n    # Using EasyOCR\n    result = await extract_file(\n        \"document.jpg\", config=ExtractionConfig(ocr_backend=\"easyocr\", ocr_config=EasyOCRConfig(language_list=[\"en\", \"de\"]))\n    )\n    print(f\"EasyOCR result: {result.content[:100]}...\")\n\n    # Using PaddleOCR\n    result = await extract_file(\n        \"chinese_document.jpg\",\n        config=ExtractionConfig(ocr_backend=\"paddleocr\", ocr_config=PaddleOCRConfig(language=\"ch\")),  # Chinese\n    )\n    print(f\"PaddleOCR result: {result.content[:100]}...\")\n\n    # Disable OCR completely\n    result = await extract_file(\"searchable_pdf.pdf\", config=ExtractionConfig(ocr_backend=None))\n    print(f\"No OCR result: {result.content[:100]}...\")\n</code></pre>"},{"location":"examples/extraction-examples/#table-extraction","title":"Table Extraction","text":"<pre><code>from kreuzberg import extract_file, ExtractionConfig, GMFTConfig\n\nasync def extract_tables_from_pdf():\n    # Enable table extraction with default settings\n    result = await extract_file(\"document_with_tables.pdf\", config=ExtractionConfig(extract_tables=True))\n\n    # Process extracted tables\n    print(f\"Found {len(result.tables)} tables\")\n    for i, table in enumerate(result.tables):\n        print(f\"Table {i+1} on page {table.page_number}:\")\n        print(table.text)  # Markdown formatted table\n\n        # Work with the pandas DataFrame\n        df = table.df\n        print(f\"Table shape: {df.shape}\")\n\n        # The cropped table image is also available\n        # table.cropped_image.save(f\"table_{i+1}.png\")\n\n    # With custom GMFT configuration\n    custom_config = ExtractionConfig(\n        extract_tables=True,\n        gmft_config=GMFTConfig(\n            detector_base_threshold=0.85,  # Min confidence for table detection\n            enable_multi_header=True,  # Support multi-level headers\n            semantic_spanning_cells=True,  # Handle spanning cells\n            semantic_hierarchical_left_fill=\"deep\",  # Handle hierarchical headers\n        ),\n    )\n\n    result = await extract_file(\"complex_tables.pdf\", config=custom_config)\n    # Process tables...\n</code></pre>"},{"location":"examples/extraction-examples/#batch-processing","title":"Batch Processing","text":"<pre><code>from kreuzberg import batch_extract_file, ExtractionConfig\n\nasync def process_documents():\n    file_paths = [\"document1.pdf\", \"document2.docx\", \"image.jpg\"]\n    config = ExtractionConfig()  # Optional: configure extraction options\n    results = await batch_extract_file(file_paths, config=config)\n\n    for path, result in zip(file_paths, results):\n        print(f\"File: {path}\")\n        print(f\"Content: {result.content[:100]}...\")\n</code></pre>"},{"location":"examples/extraction-examples/#working-with-bytes","title":"Working with Bytes","text":"<pre><code>from kreuzberg import extract_bytes, ExtractionConfig\n\nasync def process_upload(file_content: bytes, mime_type: str):\n    # Extract text from uploaded file content\n    config = ExtractionConfig()  # Optional: configure extraction options\n    result = await extract_bytes(file_content, mime_type=mime_type, config=config)\n    print(f\"Content: {result.content[:100]}...\")\n\n    # Access metadata\n    if result.metadata:\n        for key, value in result.metadata.items():\n            print(f\"{key}: {value}\")\n</code></pre>"},{"location":"examples/extraction-examples/#synchronous-api","title":"Synchronous API","text":"<p>For cases where async isn't needed or available:</p> <pre><code>from kreuzberg import extract_file_sync, batch_extract_file_sync, ExtractionConfig\n\n# Configuration for extraction\nconfig = ExtractionConfig()  # Optional: configure extraction options\n\n# Single file extraction\nresult = extract_file_sync(\"document.pdf\", config=config)\nprint(result.content)\n\n# Batch processing\nfile_paths = [\"document1.pdf\", \"document2.docx\", \"image.jpg\"]\nresults = batch_extract_file_sync(file_paths, config=config)\nfor path, result in zip(file_paths, results):\n    print(f\"File: {path}\")\n    print(f\"Content: {result.content[:100]}...\")\n</code></pre>"},{"location":"examples/extraction-examples/#error-handling","title":"Error Handling","text":"<pre><code>from kreuzberg import extract_file, ExtractionConfig\nfrom kreuzberg import KreuzbergError, MissingDependencyError, OCRError\n\nasync def safe_extract(path):\n    try:\n        config = ExtractionConfig()  # Optional: configure extraction options\n        result = await extract_file(path, config=config)\n        return result.content\n    except MissingDependencyError as e:\n        print(f\"Missing dependency: {e}\")\n        print(\"Please install the required dependencies.\")\n    except OCRError as e:\n        print(f\"OCR processing failed: {e}\")\n    except KreuzbergError as e:\n        print(f\"Extraction error: {e}\")\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n\n    return None\n</code></pre>"},{"location":"getting-started/","title":"Getting Started with Kreuzberg","text":"<p>Welcome to Kreuzberg! This section will help you get up and running quickly with text extraction.</p>"},{"location":"getting-started/#overview","title":"Overview","text":"<p>Kreuzberg is a Python library for extracting text from various document formats including PDFs, images, Office documents, and more. It provides both asynchronous and synchronous APIs for easy integration into any Python application.</p>"},{"location":"getting-started/#quick-navigation","title":"Quick Navigation","text":"<ul> <li>Installation - Install Kreuzberg and its dependencies</li> <li>Quick Start - Basic usage examples to get you started</li> </ul>"},{"location":"getting-started/#key-features","title":"Key Features","text":"<ul> <li>Multi-format Support: Extract text from PDF, image, Word, Excel, PowerPoint, and more</li> <li>OCR Capabilities: Process scanned documents and images with OCR</li> <li>Multiple OCR Engines: Choose from Tesseract, EasyOCR, or PaddleOCR</li> <li>Async First: Built with modern Python async/await support</li> <li>Metadata Extraction: Get document metadata alongside text content</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Kreuzberg is composed of a core package and several <code>optional</code> dependencies, which users can install at their discretion.</p>"},{"location":"getting-started/installation/#system-dependencies","title":"System Dependencies","text":""},{"location":"getting-started/installation/#pandoc","title":"Pandoc","text":"<p>Kreuzberg relies on <code>pandoc</code>, which is a required system dependency. To install it, follow the instructions below:</p>"},{"location":"getting-started/installation/#ubuntudebian","title":"Ubuntu/Debian","text":"<pre><code>sudo apt-get install pandoc\n</code></pre>"},{"location":"getting-started/installation/#macos","title":"macOS","text":"<pre><code>brew install pandoc\n</code></pre>"},{"location":"getting-started/installation/#windows","title":"Windows","text":"<pre><code>choco install -y pandoc\n</code></pre>"},{"location":"getting-started/installation/#kreuzberg-core-package","title":"Kreuzberg Core Package","text":"<p>The Kreuzberg core package can be installed using pip with:</p> <pre><code>pip install kreuzberg\n</code></pre>"},{"location":"getting-started/installation/#optional-features","title":"Optional Features","text":""},{"location":"getting-started/installation/#ocr","title":"OCR","text":"<p>OCR is an optional feature for extracting text from images and non-searchable PDFs. Kreuzberg supports multiple OCR backends. To understand the differences between these backends, please read the OCR Backends documentation.</p>"},{"location":"getting-started/installation/#tesseract-ocr","title":"Tesseract OCR","text":"<p>Tesseract OCR is built into Kreuzberg and doesn't require additional Python packages. However, you must install Tesseract 5.0 or higher on your system:</p>"},{"location":"getting-started/installation/#ubuntudebian_1","title":"Ubuntu/Debian","text":"<pre><code>sudo apt-get install tesseract-ocr\n</code></pre>"},{"location":"getting-started/installation/#macos_1","title":"macOS","text":"<pre><code>brew install tesseract\n</code></pre>"},{"location":"getting-started/installation/#windows_1","title":"Windows","text":"<pre><code>choco install -y tesseract\n</code></pre> <p>Language Support</p> <p>Tesseract includes English language support by default. If you need to process documents in other languages, you must install the appropriate language data files:</p> <ul> <li>Ubuntu/Debian: <code>sudo apt-get install tesseract-ocr-deu</code> (for German)</li> <li>macOS: <code>brew install tesseract-lang</code></li> <li>Windows: See the Tesseract documentation</li> </ul> <p>For more details on language installation and configuration, refer to the Tesseract documentation.</p>"},{"location":"getting-started/installation/#easyocr","title":"EasyOCR","text":"<p>EasyOCR is a Python-based OCR backend with wide language support and strong performance.</p> <pre><code>pip install \"kreuzberg[easyocr]\"\n</code></pre>"},{"location":"getting-started/installation/#paddleocr","title":"PaddleOCR","text":"<pre><code>pip install \"kreuzberg[paddleocr]\"\n</code></pre>"},{"location":"getting-started/installation/#chunking","title":"Chunking","text":"<p>Chunking is an optional feature - useful for RAG applications among others. Kreuzberg uses the excellent <code>semantic-text-splitter</code> package for chunking. To install Kreuzberg with chunking support, you can use:</p> <pre><code>pip install \"kreuzberg[chunking]\"\n</code></pre>"},{"location":"getting-started/installation/#table-extraction","title":"Table Extraction","text":"<p>Table extraction is an optional feature that allows Kreuzberg to extract tables from PDFs. It uses the GMFT package. To install Kreuzberg with table extraction support, you can use:</p> <pre><code>pip install \"kreuzberg[gmft]\"\n</code></pre>"},{"location":"getting-started/installation/#all-optional-dependencies","title":"All Optional Dependencies","text":"<p>To install Kreuzberg with all optional dependencies, you can use the <code>all</code> extra group:</p> <pre><code>pip install \"kreuzberg[all]\"\n</code></pre> <p>This is equivalent to:</p> <pre><code>pip install \"kreuzberg[chunking,easyocr,gmft,paddleocr]\"\n</code></pre>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get started with Kreuzberg for text extraction from documents and images.</p>"},{"location":"getting-started/quick-start/#basic-usage","title":"Basic Usage","text":"<p>Kreuzberg provides both asynchronous and synchronous APIs for text extraction.</p>"},{"location":"getting-started/quick-start/#async-api-recommended","title":"Async API (Recommended)","text":"<pre><code>import asyncio\nfrom kreuzberg import extract_file\n\nasync def main():\n    # Extract text from a PDF file\n    result = await extract_file(\"document.pdf\")\n    print(result.content)\n\n    # The result also contains metadata\n    print(f\"Mime type: {result.mime_type}\")\n    print(f\"Extraction method: {result.extraction_method}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quick-start/#synchronous-api","title":"Synchronous API","text":"<pre><code>from kreuzberg import extract_file_sync\n\n# Extract text from a PDF file\nresult = extract_file_sync(\"document.pdf\")\nprint(result.content)\n</code></pre>"},{"location":"getting-started/quick-start/#ocr-configuration","title":"OCR Configuration","text":"<p>Kreuzberg supports OCR for images and scanned PDFs with configurable language and page segmentation mode:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, TesseractConfig, PSMMode\n\nasync def main():\n    # Extract text from an image with German language model\n    result = await extract_file(\n        \"german_document.jpg\",\n        config=ExtractionConfig(\n            ocr_config=TesseractConfig(\n                language=\"deu\", psm=PSMMode.SINGLE_BLOCK  # German language model  # Treat as a single text block\n            )\n        ),\n    )\n    print(result.content)\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/quick-start/#batch-processing","title":"Batch Processing","text":"<p>Process multiple files concurrently:</p> <pre><code>from pathlib import Path\nfrom kreuzberg import batch_extract_file\n\nasync def process_documents():\n    file_paths = [Path(\"document1.pdf\"), Path(\"document2.docx\"), Path(\"image.jpg\")]\n\n    # Process all files concurrently\n    results = await batch_extract_file(file_paths)\n\n    # Results are returned in the same order as inputs\n    for path, result in zip(file_paths, results):\n        print(f\"File: {path}\")\n        print(f\"Content: {result.content[:100]}...\")  # First 100 chars\n        print(f\"Mime type: {result.mime_type}\")\n        print(f\"Method: {result.extraction_method}\")\n        print(\"---\")\n\nasyncio.run(process_documents())\n</code></pre>"},{"location":"getting-started/quick-start/#error-handling","title":"Error Handling","text":"<p>Kreuzberg provides specific exceptions for different error cases:</p> <pre><code>from kreuzberg import extract_file\nfrom kreuzberg import KreuzbergError, MissingDependencyError, OCRError, ParsingError\n\nasync def safe_extract(path):\n    try:\n        result = await extract_file(path)\n        return result.content\n    except ParsingError:\n        print(f\"Unsupported or invalid file format: {path}\")\n    except MissingDependencyError as e:\n        print(f\"Missing dependency: {e}\")\n    except OCRError as e:\n        print(f\"OCR processing failed: {e}\")\n    except KreuzbergError as e:\n        print(f\"Extraction failed: {e}\")\n    return None\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Check the OCR Configuration guide for detailed OCR options</li> <li>See Supported Formats for all file types Kreuzberg can process</li> <li>Explore the API Reference for detailed function documentation</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>This guide covers the main concepts and usage patterns of Kreuzberg.</p>"},{"location":"user-guide/#contents","title":"Contents","text":"<ul> <li>Basic Usage - Essential usage patterns and concepts (API)</li> <li>Extraction Configuration - Configure the extraction process (API)</li> <li>Metadata Extraction - Document metadata extraction (API)</li> <li>Content Chunking - Split documents into manageable chunks</li> <li>OCR Configuration - Configure OCR settings (API)</li> <li>OCR Backends - Choose and configure different OCR engines</li> <li>Supported Formats - All supported document formats</li> </ul>"},{"location":"user-guide/#best-practices","title":"Best Practices","text":"<ul> <li>Use the async API for better performance in web applications and concurrent extraction</li> <li>Configure OCR language settings to match your document languages for better accuracy</li> <li>For large documents, consider file streaming methods to reduce memory usage</li> <li>When processing many similar documents, reuse configuration objects for consistency</li> </ul>"},{"location":"user-guide/#common-use-cases","title":"Common Use Cases","text":"<p>Document Analysis:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig\n\nasync def analyze_document(file_path):\n    result = await extract_file(file_path, config=ExtractionConfig())\n\n    # Get basic document content\n    text = result.content\n\n    # Access metadata\n    title = result.metadata.get(\"title\", \"Untitled\")\n    author = result.metadata.get(\"authors\", [\"Unknown\"])[0]\n\n    return {\"title\": title, \"author\": author, \"content\": text, \"word_count\": len(text.split()), \"char_count\": len(text)}\n</code></pre>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":"<p>Kreuzberg offers a simple API for text extraction from documents and images.</p>"},{"location":"user-guide/basic-usage/#core-functions","title":"Core Functions","text":"<p>Kreuzberg exports the following main functions:</p>"},{"location":"user-guide/basic-usage/#single-item-processing","title":"Single Item Processing","text":"<ul> <li><code>extract_file()</code>: Async function to extract text from a file (accepts string path or <code>pathlib.Path</code>)</li> <li><code>extract_bytes()</code>: Async function to extract text from bytes (accepts a byte string)</li> <li><code>extract_file_sync()</code>: Synchronous version of <code>extract_file()</code></li> <li><code>extract_bytes_sync()</code>: Synchronous version of <code>extract_bytes()</code></li> </ul>"},{"location":"user-guide/basic-usage/#batch-processing","title":"Batch Processing","text":"<ul> <li><code>batch_extract_file()</code>: Async function to extract text from multiple files concurrently</li> <li><code>batch_extract_bytes()</code>: Async function to extract text from multiple byte contents concurrently</li> <li><code>batch_extract_file_sync()</code>: Synchronous version of <code>batch_extract_file()</code></li> <li><code>batch_extract_bytes_sync()</code>: Synchronous version of <code>batch_extract_bytes()</code></li> </ul>"},{"location":"user-guide/basic-usage/#async-examples","title":"Async Examples","text":""},{"location":"user-guide/basic-usage/#extract-text-from-a-file","title":"Extract Text from a File","text":"<pre><code>import asyncio\nfrom kreuzberg import extract_file\n\nasync def main():\n    result = await extract_file(\"document.pdf\")\n    print(result.content)\n    print(f\"MIME type: {result.mime_type}\")\n    print(f\"Metadata: {result.metadata}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"user-guide/basic-usage/#process-multiple-files-concurrently","title":"Process Multiple Files Concurrently","text":"<pre><code>import asyncio\nfrom pathlib import Path\nfrom kreuzberg import batch_extract_file\n\nasync def process_documents():\n    file_paths = [Path(\"document1.pdf\"), Path(\"document2.docx\"), Path(\"image.jpg\")]\n\n    # Process all files concurrently\n    results = await batch_extract_file(file_paths)\n\n    # Results are returned in the same order as inputs\n    for path, result in zip(file_paths, results):\n        print(f\"File: {path}\")\n        print(f\"Content: {result.content[:100]}...\")  # First 100 chars\n        print(f\"MIME type: {result.mime_type}\")\n        print(\"---\")\n\nasyncio.run(process_documents())\n</code></pre>"},{"location":"user-guide/basic-usage/#synchronous-examples","title":"Synchronous Examples","text":""},{"location":"user-guide/basic-usage/#extract-text-from-a-file_1","title":"Extract Text from a File","text":"<pre><code>from kreuzberg import extract_file_sync\n\nresult = extract_file_sync(\"document.pdf\")\nprint(result.content)\n</code></pre>"},{"location":"user-guide/basic-usage/#process-multiple-files","title":"Process Multiple Files","text":"<pre><code>from kreuzberg import batch_extract_file_sync\n\nfile_paths = [\"document1.pdf\", \"document2.docx\", \"image.jpg\"]\nresults = batch_extract_file_sync(file_paths)\n\nfor path, result in zip(file_paths, results):\n    print(f\"File: {path}\")\n    print(f\"Content: {result.content[:100]}...\")\n</code></pre>"},{"location":"user-guide/basic-usage/#working-with-byte-content","title":"Working with Byte Content","text":"<p>If you already have the file content in memory, you can use the bytes extraction functions:</p> <pre><code>import asyncio\nfrom kreuzberg import extract_bytes\n\nasync def extract_from_memory():\n    with open(\"document.pdf\", \"rb\") as f:\n        content = f.read()\n\n    result = await extract_bytes(content, mime_type=\"application/pdf\")\n    print(result.content)\n\nasyncio.run(extract_from_memory())\n</code></pre>"},{"location":"user-guide/basic-usage/#extraction-result","title":"Extraction Result","text":"<p>All extraction functions return an <code>ExtractionResult</code> object containing:</p> <ul> <li><code>content</code>: Extracted text</li> <li><code>mime_type</code>: Document MIME type</li> <li><code>metadata</code>: Document metadata (see Metadata Extraction)</li> </ul> <pre><code>from kreuzberg import extract_file, ExtractionResult  # Import types directly from kreuzberg\n\nasync def show_metadata():\n    result: ExtractionResult = await extract_file(\"document.pdf\")\n\n    # Access the content\n    print(result.content)\n\n    # Access metadata (if available)\n    if \"title\" in result.metadata:\n        print(f\"Title: {result.metadata['title']}\")\n\n    if \"authors\" in result.metadata:\n        print(f\"Authors: {', '.join(result.metadata['authors'])}\")\n\n    if \"created_at\" in result.metadata:\n        print(f\"Created: {result.metadata['created_at']}\")\n\nasyncio.run(show_metadata())\n</code></pre>"},{"location":"user-guide/chunking/","title":"Content Chunking","text":"<p>Kreuzberg provides a powerful content chunking capability that allows you to split extracted text into smaller, more manageable chunks. This feature is particularly useful for processing large documents, working with language models that have token limits, or implementing semantic search functionality.</p>"},{"location":"user-guide/chunking/#overview","title":"Overview","text":"<p>Content chunking divides the extracted text into smaller segments while maintaining semantic coherence. Kreuzberg uses the <code>semantic-text-splitter</code> library to intelligently split text based on content type (plain text or markdown), respecting the document's structure.</p>"},{"location":"user-guide/chunking/#configuration","title":"Configuration","text":"<p>Chunking is controlled through the <code>ExtractionConfig</code> class with these parameters:</p> <ul> <li><code>chunk_content</code>: Boolean flag to enable/disable chunking (default: <code>False</code>)</li> <li><code>max_chars</code>: Maximum number of characters per chunk (default: 4000)</li> <li><code>max_overlap</code>: Number of characters to overlap between chunks (default: 200)</li> </ul>"},{"location":"user-guide/chunking/#basic-usage","title":"Basic Usage","text":"<p>To enable chunking in your extraction process:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig\n\n# Enable chunking with default chunk size and overlap\nresult = await extract_file(\"large_document.pdf\", config=ExtractionConfig(chunk_content=True))\n\n# Access the full content\nfull_text = result.content\n\n# Access individual chunks\nfor i, chunk in enumerate(result.chunks):\n    print(f\"Chunk {i+1}, length: {len(chunk)} characters\")\n    print(f\"Preview: {chunk[:100]}...\\n\")\n</code></pre>"},{"location":"user-guide/chunking/#customizing-chunk-size-and-overlap","title":"Customizing Chunk Size and Overlap","text":"<p>You can customize the chunk size and overlap to suit your specific needs:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig\n\n# Custom chunk size (2000 characters) and overlap (100 characters)\nresult = await extract_file(\"large_document.pdf\", config=ExtractionConfig(chunk_content=True, max_chars=2000, max_overlap=100))\n</code></pre>"},{"location":"user-guide/chunking/#format-aware-chunking","title":"Format-Aware Chunking","text":"<p>Kreuzberg's chunking system is format-aware, meaning it handles different content types appropriately:</p> <ul> <li>Markdown: When extracting from formats that produce markdown output (like DOCX, PPTX), the chunker preserves markdown structure, avoiding breaks in the middle of headings, lists, or code blocks.</li> <li>Plain Text: For plain text output, the chunker attempts to split on natural boundaries like paragraph breaks and sentences.</li> </ul>"},{"location":"user-guide/chunking/#use-cases","title":"Use Cases","text":""},{"location":"user-guide/chunking/#working-with-large-language-models","title":"Working with Large Language Models","text":"<p>When using LLMs with token limits, chunking allows you to process documents that would otherwise exceed those limits:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig\n\n# Extract with chunking enabled\nresult = await extract_file(\"large_report.pdf\", config=ExtractionConfig(chunk_content=True))\n\n# Process each chunk with an LLM\nsummaries = []\nfor chunk in result.chunks:\n    # Process chunk with your LLM of choice\n    summary = await process_with_llm(chunk)\n    summaries.append(summary)\n\n# Combine the results\nfinal_summary = \"\\n\\n\".join(summaries)\n</code></pre>"},{"location":"user-guide/chunking/#semantic-search-implementation","title":"Semantic Search Implementation","text":"<p>Chunking is essential for implementing effective semantic search:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig\nimport numpy as np\n\n# Extract with chunking enabled\nresult = await extract_file(\"knowledge_base.pdf\", config=ExtractionConfig(chunk_content=True))\n\n# Create embeddings for each chunk (using a hypothetical embedding function)\nembeddings = [create_embedding(chunk) for chunk in result.chunks]\n\n# Search function\ndef semantic_search(query, chunks, embeddings, top_k=3):\n    query_embedding = create_embedding(query)\n\n    # Calculate similarity scores\n    similarities = [np.dot(query_embedding, emb) for emb in embeddings]\n\n    # Get indices of top results\n    top_indices = sorted(range(len(similarities)), key=lambda i: similarities[i], reverse=True)[:top_k]\n\n    # Return top chunks\n    return [chunks[i] for i in top_indices]\n\n# Example usage\nresults = semantic_search(\"renewable energy benefits\", result.chunks, embeddings)\n</code></pre>"},{"location":"user-guide/chunking/#technical-details","title":"Technical Details","text":"<p>Under the hood, Kreuzberg uses the <code>semantic-text-splitter</code> library which intelligently splits text while preserving semantic structure. The chunking process:</p> <ol> <li>Identifies the content type (markdown or plain text)</li> <li>Creates an appropriate splitter based on the content type</li> <li>Splits the content according to the specified maximum size and overlap</li> <li>Returns the chunks as a list of strings in the <code>ExtractionResult.chunks</code> field</li> </ol> <p>The chunker is cached for performance, so creating multiple extraction results with the same chunking parameters is efficient.</p>"},{"location":"user-guide/chunking/#best-practices","title":"Best Practices","text":"<ul> <li>Choose appropriate chunk sizes: Smaller chunks (1000-2000 characters) work well for precise semantic search, while larger chunks (4000-8000 characters) may be better for context-aware processing.</li> <li>Set meaningful overlap: Overlap ensures that context isn't lost between chunks. A good rule of thumb is 5-10% of your chunk size.</li> <li>Consider content type: Markdown content may require larger chunk sizes to preserve structure.</li> <li>Test with your specific use case: Optimal chunking parameters depend on your specific documents and use case.</li> </ul>"},{"location":"user-guide/extraction-configuration/","title":"Extraction Configuration","text":"<p>Kreuzberg provides extensive configuration options for the extraction process through the <code>ExtractionConfig</code> class. This guide covers common configuration scenarios and examples.</p>"},{"location":"user-guide/extraction-configuration/#basic-configuration","title":"Basic Configuration","text":"<p>All extraction functions accept an optional <code>config</code> parameter of type <code>ExtractionConfig</code>. This object allows you to:</p> <ul> <li>Control OCR behavior with <code>force_ocr</code> and <code>ocr_backend</code></li> <li>Provide engine-specific OCR configuration via <code>ocr_config</code></li> <li>Enable table extraction with <code>extract_tables</code> and configure it via <code>gmft_config</code></li> <li>Add validation and post-processing hooks</li> <li>Configure custom extractors</li> </ul>"},{"location":"user-guide/extraction-configuration/#examples","title":"Examples","text":""},{"location":"user-guide/extraction-configuration/#basic-usage","title":"Basic Usage","text":"<pre><code>from kreuzberg import extract_file, ExtractionConfig\n\n# Simple extraction with default configuration\nresult = await extract_file(\"document.pdf\")\n\n# Extraction with custom configuration\nresult = await extract_file(\"document.pdf\", config=ExtractionConfig(force_ocr=True))\n</code></pre>"},{"location":"user-guide/extraction-configuration/#ocr-configuration","title":"OCR Configuration","text":"<pre><code>from kreuzberg import extract_file, ExtractionConfig, TesseractConfig, PSMMode\n\n# Configure Tesseract OCR with specific language and page segmentation mode\nresult = await extract_file(\n    \"document.pdf\",\n    config=ExtractionConfig(force_ocr=True, ocr_config=TesseractConfig(language=\"eng+deu\", psm=PSMMode.SINGLE_BLOCK)),\n)\n</code></pre> <p>The <code>language</code> parameter specifies which language model Tesseract should use. You can specify multiple languages by joining them with a plus sign (e.g., \"eng+deu\" for English and German).</p> <p>The <code>psm</code> (Page Segmentation Mode) parameter controls how Tesseract analyzes page layout. Different modes are suitable for different types of documents:</p> <ul> <li><code>PSMMode.AUTO</code>: Automatic page segmentation (default)</li> <li><code>PSMMode.SINGLE_BLOCK</code>: Treat the image as a single text block</li> <li><code>PSMMode.SINGLE_LINE</code>: Treat the image as a single text line</li> <li><code>PSMMode.SINGLE_WORD</code>: Treat the image as a single word</li> <li><code>PSMMode.SINGLE_CHAR</code>: Treat the image as a single character</li> </ul>"},{"location":"user-guide/extraction-configuration/#alternative-ocr-engines","title":"Alternative OCR Engines","text":"<pre><code>from kreuzberg import extract_file, ExtractionConfig, EasyOCRConfig, PaddleOCRConfig\n\n# Use EasyOCR backend\nresult = await extract_file(\n    \"document.jpg\", config=ExtractionConfig(ocr_backend=\"easyocr\", ocr_config=EasyOCRConfig(language_list=[\"en\", \"de\"]))\n)\n\n# Use PaddleOCR backend\nresult = await extract_file(\n    \"chinese_document.jpg\", config=ExtractionConfig(ocr_backend=\"paddleocr\", ocr_config=PaddleOCRConfig(language=\"ch\"))\n)\n</code></pre>"},{"location":"user-guide/extraction-configuration/#table-extraction","title":"Table Extraction","text":"<p>Kreuzberg can extract tables from PDF documents using the GMFT package:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, GMFTConfig\n\n# Extract tables with default configuration\nresult = await extract_file(\"document_with_tables.pdf\", config=ExtractionConfig(extract_tables=True))\n\n# Extract tables with custom configuration\nconfig = ExtractionConfig(\n    extract_tables=True,\n    gmft_config=GMFTConfig(\n        detector_base_threshold=0.85,  # Minimum confidence score required for a table\n        remove_null_rows=True,  # Remove rows with no text\n        enable_multi_header=True,  # Enable multi-indices in the dataframe\n    ),\n)\nresult = await extract_file(\"document_with_tables.pdf\", config=config)\n\n# Access extracted tables\nfor i, table in enumerate(result.tables):\n    print(f\"Table {i+1} on page {table.page_number}:\")\n    print(table.text)  # Markdown formatted table text\n    # You can also access the pandas DataFrame directly\n    df = table.df\n    print(df.shape)  # (rows, columns)\n</code></pre> <p>Note that table extraction requires the <code>gmft</code> dependency. You can install it with:</p> <pre><code>pip install \"kreuzberg[gmft]\"\n</code></pre>"},{"location":"user-guide/extraction-configuration/#batch-processing","title":"Batch Processing","text":"<pre><code>from kreuzberg import batch_extract_file, ExtractionConfig\n\n# Process multiple files with the same configuration\nfile_paths = [\"document1.pdf\", \"document2.docx\", \"image.jpg\"]\nconfig = ExtractionConfig(force_ocr=True)\nresults = await batch_extract_file(file_paths, config=config)\n</code></pre>"},{"location":"user-guide/extraction-configuration/#synchronous-api","title":"Synchronous API","text":"<pre><code>from kreuzberg import extract_file_sync, ExtractionConfig, TesseractConfig\n\n# Synchronous extraction with configuration\nresult = extract_file_sync(\"document.pdf\", config=ExtractionConfig(ocr_config=TesseractConfig(language=\"eng\")))\n</code></pre>"},{"location":"user-guide/extraction-configuration/#using-custom-extractors","title":"Using Custom Extractors","text":"<p>You can register custom extractors to handle specific file formats:</p> <pre><code>from kreuzberg import ExtractorRegistry, extract_file, ExtractionConfig\nfrom my_module import CustomExtractor\n\n# Register a custom extractor\nExtractorRegistry.add_extractor(CustomExtractor)\n\n# Now extraction functions will use your custom extractor for supported MIME types\nresult = await extract_file(\"custom_document.xyz\")\n\n# Later, remove the extractor if needed\nExtractorRegistry.remove_extractor(CustomExtractor)\n</code></pre> <p>See the Custom Extractors guide for more details on creating and registering custom extractors.</p>"},{"location":"user-guide/extraction-configuration/#ocr-best-practices","title":"OCR Best Practices","text":"<p>When configuring OCR for your documents, consider these best practices:</p> <ol> <li> <p>Language Selection: Choose the appropriate language model for your documents. Using the wrong language model can significantly reduce OCR accuracy.</p> </li> <li> <p>Page Segmentation Mode: Select the appropriate PSM based on your document layout:</p> <ul> <li>Use <code>PSMMode.AUTO</code> for general documents with mixed content</li> <li>Use <code>PSMMode.SINGLE_BLOCK</code> for documents with a single column of text</li> <li>Use <code>PSMMode.SINGLE_LINE</code> for receipts or single-line text</li> <li>Use <code>PSMMode.SINGLE_WORD</code> or <code>PSMMode.SINGLE_CHAR</code> for specialized cases</li> </ul> </li> <li> <p>OCR Engine Selection: Choose the appropriate OCR engine based on your needs:</p> <ul> <li>Tesseract: Good general-purpose OCR with support for many languages</li> <li>EasyOCR: Better for some non-Latin scripts and natural scene text</li> <li>PaddleOCR: Excellent for Chinese and other Asian languages</li> </ul> </li> <li> <p>Preprocessing: For better OCR results, consider using validation and post-processing hooks to clean up the extracted text.</p> </li> </ol>"},{"location":"user-guide/metadata-extraction/","title":"Metadata Extraction","text":"<p>Kreuzberg automatically extracts rich metadata from documents including titles, authors, dates, and format-specific properties.</p>"},{"location":"user-guide/metadata-extraction/#how-it-works","title":"How It Works","text":"<p>The <code>ExtractionResult</code> includes a <code>metadata</code> dictionary with available metadata properties. Each format uses specialized extractors:</p> <ul> <li>PDF: Uses Playa to extract document information, structure, and properties</li> <li>Office: Uses Pandoc for Word, PowerPoint, and other formats</li> <li>Images: Extracts dimensions and format properties</li> <li>HTML: Extracts meta tags and structured data</li> </ul>"},{"location":"user-guide/metadata-extraction/#metadata-fields","title":"Metadata Fields","text":"<p>The <code>Metadata</code> dictionary is a <code>TypedDict</code> with optional fields. Only available fields are included in the results.</p>"},{"location":"user-guide/metadata-extraction/#usage-example","title":"Usage Example","text":"<p>Accessing document metadata:</p> <pre><code>from kreuzberg import extract_file\n\n# Extract from a file\nresult = await extract_file(\"document.pdf\")\n\n# Access metadata - use .get() with a default value for safety\ntitle = result.metadata.get(\"title\", \"Untitled Document\")\nauthors = result.metadata.get(\"authors\", [\"Unknown Author\"])\ncreated_date = result.metadata.get(\"created_at\")\n\n# Print available metadata\nprint(\"Available metadata fields:\")\nfor key, value in result.metadata.items():\n    print(f\"{key}: {value}\")\n</code></pre>"},{"location":"user-guide/metadata-extraction/#pdf-specific-metadata","title":"PDF-Specific Metadata","text":"<p>For PDF documents, Kreuzberg extracts a rich set of metadata including:</p> <ul> <li>Document information dictionary values (title, author, subject, keywords, etc.)</li> <li>Document structure information including page count, dimensions, and outline</li> <li>Font information from document pages</li> <li>PDF/A compliance status</li> <li>Encryption status and permissions</li> <li>Language information when available in document structure</li> </ul> <p>If a PDF document contains UTF-16BE encoded strings (often present in PDF metadata with a byte order mark <code>\\xfe\\xff</code>), Kreuzberg will automatically detect and decode these properly.</p>"},{"location":"user-guide/metadata-extraction/#working-with-multiple-document-types","title":"Working with Multiple Document Types","text":"<p>When working with multiple document types, it's important to remember that different document formats may provide different metadata fields. Always use defensive programming (like using <code>.get()</code> with a default value) when accessing metadata fields:</p> <pre><code># Safe way to access metadata across different document types\nauthor = result.metadata.get(\"authors\", [\"Unknown\"])[0] if \"authors\" in result.metadata else \"Unknown\"\ncreation_date = result.metadata.get(\"created_at\", \"Unknown date\")\n</code></pre>"},{"location":"user-guide/metadata-extraction/#viewing-available-metadata","title":"Viewing Available Metadata","text":"<p>To view all available metadata for a document:</p> <pre><code>from kreuzberg import extract_file\nimport json\n\nresult = await extract_file(\"your_file.pdf\")\nprint(json.dumps(result.metadata, indent=2, default=str))\n</code></pre> <p>This will print all available metadata fields for the document in a readable format.</p>"},{"location":"user-guide/ocr-backends/","title":"OCR Backends","text":"<p>Kreuzberg supports multiple OCR (Optical Character Recognition) backends, giving you flexibility to choose the best option for your specific needs. Each backend has different strengths, language support, and installation requirements.</p>"},{"location":"user-guide/ocr-backends/#supported-backends","title":"Supported Backends","text":""},{"location":"user-guide/ocr-backends/#1-tesseract-ocr","title":"1. Tesseract OCR","text":"<p>Tesseract OCR is the default OCR backend in Kreuzberg. It's a mature, open-source OCR engine with support for over 100 languages.</p> <p>Installation Requirements:</p> <ul> <li>Requires system-level installation</li> <li>Minimum required version: Tesseract 5.0</li> </ul> <p>Installation Instructions:</p> <pre><code># Ubuntu/Debian\nsudo apt-get install tesseract-ocr\n\n# macOS\nbrew install tesseract\n\n# Windows\nchoco install -y tesseract\n</code></pre> <p>Language Support:</p> <ul> <li>For languages other than English, install additional language packs:<ul> <li>Ubuntu: <code>sudo apt-get install tesseract-ocr-deu</code> (for German)</li> <li>macOS: <code>brew install tesseract-lang</code></li> </ul> </li> </ul> <p>Configuration:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, TesseractConfig, PSMMode\n\nresult = await extract_file(\n    \"document.pdf\",\n    config=ExtractionConfig(\n        ocr_backend=\"tesseract\",  # This is the default\n        ocr_config=TesseractConfig(language=\"eng+deu\", psm=PSMMode.AUTO),  # English and German  # Page segmentation mode\n    ),\n)\n</code></pre>"},{"location":"user-guide/ocr-backends/#2-easyocr","title":"2. EasyOCR","text":"<p>EasyOCR is a Python library that uses deep learning models for OCR. It supports over 80 languages and can be more accurate for certain scripts.</p> <p>Installation Requirements:</p> <ul> <li>Requires the <code>easyocr</code> optional dependency</li> <li>Install with: <code>pip install \"kreuzberg[easyocr]\"</code></li> </ul> <p>GPU Support:</p> <p>Experimental Feature</p> <p>GPU support is not considered an official feature and might be subject to change or removal in future versions.</p> <ul> <li>EasyOCR can use GPU acceleration when PyTorch with CUDA is available</li> <li>To enable GPU, set <code>use_gpu=True</code> in the configuration</li> <li>Kreuzberg will automatically check if CUDA is available via PyTorch</li> </ul> <p>Language Support:</p> <ul> <li>Uses different language codes than Tesseract</li> <li>Examples: <code>en</code> (English), <code>de</code> (German), <code>zh</code> (Chinese), etc.</li> <li>See the EasyOCR documentation for the full list</li> </ul> <p>Configuration:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, EasyOCRConfig\n\nresult = await extract_file(\n    \"document.jpg\",\n    config=ExtractionConfig(\n        ocr_backend=\"easyocr\",\n        ocr_config=EasyOCRConfig(\n            language_list=[\"en\", \"de\"], use_gpu=True  # English and German  # Enable GPU acceleration if available (experimental)\n        ),\n    ),\n)\n</code></pre>"},{"location":"user-guide/ocr-backends/#3-paddleocr","title":"3. PaddleOCR","text":"<p>PaddleOCR is an OCR toolkit developed by Baidu. It's particularly strong for Chinese and other Asian languages.</p> <p>Installation Requirements:</p> <ul> <li>Requires the <code>paddleocr</code> optional dependency</li> <li>Install with: <code>pip install \"kreuzberg[paddleocr]\"</code></li> </ul> <p>GPU Support:</p> <p>Experimental Feature</p> <p>GPU support is not considered an official feature and might be subject to change or removal in future versions.</p> <ul> <li>PaddleOCR can utilize GPU acceleration if the paddlepaddle-gpu package is installed</li> <li>Kreuzberg automatically detects if paddlepaddle-gpu is available</li> <li>To explicitly enable GPU, set <code>use_gpu=True</code> in the configuration</li> <li>For GPU usage, install: <code>pip install paddlepaddle-gpu</code> instead of the standard paddlepaddle package</li> </ul> <p>Language Support:</p> <ul> <li>Limited language support compared to other backends</li> <li>Supported languages: <code>ch</code> (Chinese), <code>en</code> (English), <code>french</code>, <code>german</code>, <code>japan</code>, <code>korean</code></li> </ul> <p>Configuration:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, PaddleOCRConfig\n\nresult = await extract_file(\n    \"chinese_document.jpg\",\n    config=ExtractionConfig(\n        ocr_backend=\"paddleocr\",\n        ocr_config=PaddleOCRConfig(\n            language=\"ch\",  # Chinese\n            use_gpu=True,  # Enable GPU acceleration if paddlepaddle-gpu is available (experimental)\n            gpu_mem=4000,  # Set GPU memory limit in MB (experimental)\n        ),\n    ),\n)\n</code></pre>"},{"location":"user-guide/ocr-backends/#4-no-ocr","title":"4. No OCR","text":"<p>You can also disable OCR completely, which is useful for documents that already contain searchable text.</p> <p>Configuration:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig\n\nresult = await extract_file(\"searchable_pdf.pdf\", config=ExtractionConfig(ocr_backend=None))\n</code></pre>"},{"location":"user-guide/ocr-backends/#choosing-the-right-backend","title":"Choosing the Right Backend","text":"<p>Here are some guidelines for choosing the appropriate OCR backend:</p>"},{"location":"user-guide/ocr-backends/#tesseract-ocr-default","title":"Tesseract OCR (Default)","text":"<p>Advantages:</p> <ul> <li>Lightweight and CPU-optimized</li> <li>No model downloads required (faster startup)</li> <li>Mature and widely used</li> <li>Lower memory usage</li> <li>Good for general-purpose OCR across many languages</li> <li>Good balance of accuracy and performance</li> </ul> <p>Considerations:</p> <ul> <li>Requires system-level installation</li> <li>May have lower accuracy for some languages or complex layouts</li> <li>More configuration may be needed for optimal results</li> </ul>"},{"location":"user-guide/ocr-backends/#easyocr","title":"EasyOCR","text":"<p>Advantages:</p> <ul> <li>Good accuracy across multiple languages</li> <li>No system dependencies required (pure Python)</li> <li>Simple configuration</li> <li>Better for complex scripts and languages like Arabic, Thai, or Hindi</li> <li>Can be more accurate for handwritten text</li> </ul> <p>Considerations:</p> <ul> <li>Larger memory footprint (requires PyTorch)</li> <li>Slower first-run due to model downloads</li> <li>Heavier resource usage</li> <li>Model files are downloaded on first use, causing initial delay</li> </ul>"},{"location":"user-guide/ocr-backends/#paddleocr","title":"PaddleOCR","text":"<p>Advantages:</p> <ul> <li>Excellent accuracy, especially for Asian languages</li> <li>No system dependencies required</li> <li>Modern deep learning architecture</li> <li>Fast processing once models are loaded</li> </ul> <p>Considerations:</p> <ul> <li>Largest memory footprint of the three options (requires PaddlePaddle)</li> <li>Slower first-run due to model downloads</li> <li>More resource-intensive</li> <li>Model files are downloaded on first use, causing initial delay</li> </ul>"},{"location":"user-guide/ocr-backends/#no-ocr-setting-ocr_backendnone","title":"No OCR (Setting ocr_backend=None)","text":"<p>Use when:</p> <ul> <li>Processing searchable PDFs or documents with embedded text</li> <li>You want to extract embedded text only</li> <li>You want to avoid the overhead of OCR processing</li> </ul> <p>Behavior:</p> <ul> <li>For searchable PDFs, embedded text will still be extracted</li> <li>For images and non-searchable PDFs, an empty string will be returned for content</li> <li>Fastest option as it skips OCR processing entirely</li> </ul>"},{"location":"user-guide/ocr-backends/#installation-summary","title":"Installation Summary","text":"<p>To install Kreuzberg with different OCR backends:</p> <pre><code># Basic installation (Tesseract requires separate system installation)\npip install kreuzberg\n\n# With EasyOCR support\npip install \"kreuzberg[easyocr]\"\n\n# With PaddleOCR support\npip install \"kreuzberg[paddleocr]\"\n\n# With chunking support\npip install \"kreuzberg[chunking]\"\n\n# With all optional dependencies (OCR backends and chunking)\npip install \"kreuzberg[all]\"\n</code></pre> <p>System Dependencies</p> <p>Remember that Pandoc and Tesseract are system dependencies that must be installed separately from the Python package.</p> <p>For Tesseract, you must install version 5.0 or higher, and you'll need to install additional language data files for languages other than English.</p>"},{"location":"user-guide/ocr-configuration/","title":"OCR Configuration","text":"<p>Kreuzberg offers simple configuration options for OCR to extract text from images and scanned documents.</p>"},{"location":"user-guide/ocr-configuration/#ocr-configuration_1","title":"OCR Configuration","text":"<p>All extraction functions in Kreuzberg accept an <code>ExtractionConfig</code> object that can contain OCR configuration:</p>"},{"location":"user-guide/ocr-configuration/#language-configuration","title":"Language Configuration","text":"<p>The <code>language</code> parameter in a <code>TesseractConfig</code> object specifies which language model Tesseract should use for OCR:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, TesseractConfig\n\n# Extract text from a German document\nresult = await extract_file(\"german_document.pdf\", config=ExtractionConfig(ocr_config=TesseractConfig(language=\"deu\")))\n</code></pre>"},{"location":"user-guide/ocr-configuration/#supported-language-codes","title":"Supported Language Codes","text":"Language Code Language Code English <code>eng</code> German <code>deu</code> French <code>fra</code> Spanish <code>spa</code> Italian <code>ita</code> Japanese <code>jpn</code> Korean <code>kor</code> Simplified Chinese <code>chi_sim</code> Traditional Chinese <code>chi_tra</code> Russian <code>rus</code> Arabic <code>ara</code> Hindi <code>hin</code>"},{"location":"user-guide/ocr-configuration/#multi-language-support","title":"Multi-Language Support","text":"<p>You can specify multiple languages by joining codes with a plus sign:</p> <pre><code># Document contains both English and German text\nresult = await extract_file(\"multilingual.pdf\", config=ExtractionConfig(ocr_config=TesseractConfig(language=\"eng+deu\")))\n</code></pre> <p>Note</p> <p>The order of languages affects processing time and accuracy. The first language is treated as the primary language.</p>"},{"location":"user-guide/ocr-configuration/#language-installation","title":"Language Installation","text":"<p>For Tesseract to recognize languages other than English, you need to install the corresponding language data:</p> <ul> <li>Ubuntu/Debian: <code>sudo apt-get install tesseract-ocr-&lt;lang-code&gt;</code></li> <li>macOS: <code>brew install tesseract-lang</code> (installs all languages)</li> <li>Windows: Download language data from GitHub</li> </ul>"},{"location":"user-guide/ocr-configuration/#page-segmentation-mode-psm","title":"Page Segmentation Mode (PSM)","text":"<p>The <code>psm</code> parameter in a <code>TesseractConfig</code> object controls how Tesseract analyzes the layout of the page:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig, TesseractConfig, PSMMode\n\n# Extract text from a document with a simple layout\nresult = await extract_file(\"document.pdf\", config=ExtractionConfig(ocr_config=TesseractConfig(psm=PSMMode.SINGLE_BLOCK)))\n</code></pre>"},{"location":"user-guide/ocr-configuration/#available-psm-modes","title":"Available PSM Modes","text":"Mode Enum Value Description Best For Automatic <code>PSMMode.AUTO</code> Automatic page segmentation with orientation detection General purpose (default) Single Block <code>PSMMode.SINGLE_BLOCK</code> Treat the image as a single text block Simple layouts, preserving paragraph structure Single Line <code>PSMMode.SINGLE_LINE</code> Treat the image as a single text line Receipts, labels, single-line text Single Word <code>PSMMode.SINGLE_WORD</code> Treat the image as a single word Word recognition tasks Single Character <code>PSMMode.SINGLE_CHAR</code> Treat the image as a single character Character recognition tasks Sparse Text <code>PSMMode.SPARSE_TEXT</code> Find as much text as possible without assuming structure Forms, tables, scattered text Sparse Text with OSD <code>PSMMode.SPARSE_TEXT_OSD</code> Like SPARSE_TEXT with orientation detection Complex layouts with varying text orientation"},{"location":"user-guide/ocr-configuration/#forcing-ocr","title":"Forcing OCR","text":"<p>By default, Kreuzberg will only use OCR for images and scanned PDFs. For searchable PDFs, it will extract text directly. You can override this behavior with the <code>force_ocr</code> parameter in the <code>ExtractionConfig</code> object:</p> <pre><code>from kreuzberg import extract_file, ExtractionConfig\n\n# Force OCR even for searchable PDFs\nresult = await extract_file(\"searchable.pdf\", config=ExtractionConfig(force_ocr=True))\n</code></pre> <p>This is useful when:</p> <ul> <li>The PDF contains both searchable text and images with text</li> <li>The embedded text in the PDF has encoding or extraction issues</li> <li>You want consistent processing across all documents</li> </ul>"},{"location":"user-guide/ocr-configuration/#ocr-engine-selection","title":"OCR Engine Selection","text":"<p>Kreuzberg supports multiple OCR engines:</p>"},{"location":"user-guide/ocr-configuration/#tesseract-default","title":"Tesseract (Default)","text":"<p>Tesseract is the default OCR engine and requires no additional installation beyond the system dependency.</p>"},{"location":"user-guide/ocr-configuration/#easyocr-optional","title":"EasyOCR (Optional)","text":"<p>To use EasyOCR:</p> <ol> <li>Install with the extra: <code>pip install \"kreuzberg[easyocr]\"</code></li> <li>Use the <code>ocr_backend</code> parameter in the <code>ExtractionConfig</code> object:</li> </ol> <pre><code>from kreuzberg import extract_file, ExtractionConfig, EasyOCRConfig  # EasyOCRConfig is imported from kreuzberg\n\nresult = await extract_file(\n    \"document.jpg\",\n    config=ExtractionConfig(\n        ocr_backend=\"easyocr\", ocr_config=EasyOCRConfig(language_list=[\"en\"])  # EasyOCR uses different language codes\n    ),\n)\n</code></pre>"},{"location":"user-guide/ocr-configuration/#paddleocr-optional","title":"PaddleOCR (Optional)","text":"<p>To use PaddleOCR:</p> <ol> <li>Install with the extra: <code>pip install \"kreuzberg[paddleocr]\"</code></li> <li>Use the <code>ocr_backend</code> parameter in the <code>ExtractionConfig</code> object:</li> </ol> <pre><code>from kreuzberg import extract_file, ExtractionConfig, PaddleOCRConfig  # PaddleOCRConfig is imported from kreuzberg\n\nresult = await extract_file(\n    \"document.jpg\",\n    config=ExtractionConfig(\n        ocr_backend=\"paddleocr\", ocr_config=PaddleOCRConfig(language=\"en\")  # PaddleOCR uses different language codes\n    ),\n)\n</code></pre> <p>Note</p> <p>For PaddleOCR, the supported language codes are different: <code>ch</code> (Chinese), <code>en</code> (English), <code>french</code>, <code>german</code>, <code>japan</code>, and <code>korean</code>.</p>"},{"location":"user-guide/ocr-configuration/#performance-optimization","title":"Performance Optimization","text":"<p>OCR performance and parallel processing can be controlled through process handlers and extraction hooks which are configured in the <code>ExtractionConfig</code> object. The default configuration handles performance optimization automatically.</p> <p>This is useful for:</p> <ul> <li>Limiting resource usage on systems with limited memory</li> <li>Optimizing performance on systems with many CPU cores</li> <li>Balancing OCR tasks with other application workloads</li> </ul>"},{"location":"user-guide/ocr-configuration/#best-practices","title":"Best Practices","text":"<ul> <li>Language Selection: Always specify the correct language for your documents to improve OCR accuracy</li> <li>PSM Mode Selection: Choose the appropriate PSM mode based on your document layout:<ul> <li>Use <code>PSM.SINGLE_BLOCK</code> for documents with simple layouts</li> <li>Use <code>PSM.SPARSE_TEXT</code> for forms or documents with tables</li> <li>Use <code>PSM.SINGLE_LINE</code> for receipts or labels</li> </ul> </li> <li>Image Quality: For best results, ensure images are:<ul> <li>High resolution (at least 300 DPI)</li> <li>Well-lit with good contrast</li> <li>Not skewed or rotated</li> </ul> </li> <li>Performance: For batch processing, adjust <code>max_processes</code> based on your system's capabilities</li> </ul>"},{"location":"user-guide/supported-formats/","title":"Supported Formats","text":"<p>Kreuzberg handles a wide range of document, image, and text formats.</p>"},{"location":"user-guide/supported-formats/#document-formats","title":"Document Formats","text":"<ul> <li>PDF (<code>.pdf</code>, both searchable and scanned) - includes detailed metadata extraction</li> <li>Microsoft Word (<code>.docx</code>)</li> <li>PowerPoint presentations (<code>.pptx</code>)</li> <li>OpenDocument Text (<code>.odt</code>)</li> <li>Rich Text Format (<code>.rtf</code>)</li> <li>EPUB (<code>.epub</code>)</li> <li>DocBook XML (<code>.dbk</code>, <code>.xml</code>)</li> <li>FictionBook (<code>.fb2</code>)</li> <li>LaTeX (<code>.tex</code>, <code>.latex</code>)</li> <li>Typst (<code>.typ</code>)</li> </ul>"},{"location":"user-guide/supported-formats/#markup-and-text-formats","title":"Markup and Text Formats","text":"<ul> <li>HTML (<code>.html</code>, <code>.htm</code>)</li> <li>Plain text (<code>.txt</code>) and Markdown (<code>.md</code>, <code>.markdown</code>)</li> <li>reStructuredText (<code>.rst</code>)</li> <li>Org-mode (<code>.org</code>)</li> <li>DokuWiki (<code>.txt</code>)</li> <li>Pod (<code>.pod</code>)</li> <li>Troff/Man (<code>.1</code>, <code>.2</code>, etc.)</li> </ul>"},{"location":"user-guide/supported-formats/#data-and-research-formats","title":"Data and Research Formats","text":"<ul> <li>Spreadsheets (<code>.xlsx</code>, <code>.xls</code>, <code>.xlsm</code>, <code>.xlsb</code>, <code>.xlam</code>, <code>.xla</code>, <code>.ods</code>)</li> <li>CSV (<code>.csv</code>) and TSV (<code>.tsv</code>) files</li> <li>OPML files (<code>.opml</code>)</li> <li>Jupyter Notebooks (<code>.ipynb</code>)</li> <li>BibTeX (<code>.bib</code>) and BibLaTeX (<code>.bib</code>)</li> <li>CSL-JSON (<code>.json</code>)</li> <li>EndNote and JATS XML (<code>.xml</code>)</li> <li>RIS (<code>.ris</code>)</li> </ul>"},{"location":"user-guide/supported-formats/#image-formats","title":"Image Formats","text":"<ul> <li>JPEG (<code>.jpg</code>, <code>.jpeg</code>, <code>.pjpeg</code>)</li> <li>PNG (<code>.png</code>)</li> <li>TIFF (<code>.tiff</code>, <code>.tif</code>)</li> <li>BMP (<code>.bmp</code>)</li> <li>GIF (<code>.gif</code>)</li> <li>JPEG 2000 family (<code>.jp2</code>, <code>.jpm</code>, <code>.jpx</code>, <code>.mj2</code>)</li> <li>WebP (<code>.webp</code>)</li> <li>Portable anymap formats (<code>.pbm</code>, <code>.pgm</code>, <code>.ppm</code>, <code>.pnm</code>)</li> </ul>"}]}